# Runtime Query Execution for Compiled SeqProlog Programs
#
# Provides query parsing and execution for compiled binaries.
# Generated programs include this module and call run-cli-query.

include "../parser"
include "solve"

# ============================================
# Query Parsing
# ============================================

# Parse a query string into a GoalList
# Returns gnull on parse error
: parse-query-string ( String -- GoalList Bool )
  # Tokenize the input
  tokenize

  # Parse as a term with fresh variable counter
  0 parse-term-with-counter
  drop  # drop counter

  # Check if parse succeeded
  dup parse-ok-term? if
    parse-term-value
    # Wrap single term as goal list
    gnull gcons
    true
  else
    drop gnull false
  then
;

# ============================================
# Result Printing (Prolog format)
# ============================================

# Print a substitution's variable bindings
: print-bindings ( Subst -- )
  dup subst-empty? if
    drop "true." io.write-line
  else
    print-bindings-loop
    "." io.write-line
  then
;

: print-bindings-loop ( Subst -- )
  dup subst-empty? if
    drop
  else
    dup subst-binding
    dup binding-var-id int->string
    " = " string.concat
    swap binding-value term-to-string string.concat
    io.write-line
    subst-parent print-bindings-loop
  then
;

# Print solve result in Prolog format (single solution)
: print-solve-result ( SolveResult -- )
  dup solve-success? if
    solve-success-subst print-bindings
  else
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

# Print all solutions by following choice points
: print-all-solutions ( SolveResult ClauseDB -- )
  over solve-success? if
    # Print this solution
    over solve-success-subst print-bindings

    # Check for more solutions via choice points
    over solve-success-cp-stack
    # Stack: result db cp_stack
    dup cpnil? if
      # No more choice points
      drop drop drop "false." io.write-line
    else
      # Has choice points - get next solution
      over solve-next
      # Stack: result db cp_stack next_result

      nip        # drop cp_stack
      rot drop   # drop old result
      # Stack: db next_result
      swap       # Stack: next_result db

      # Recurse
      print-all-solutions
    then
  else
    over solve-failure? if
      # No more solutions
      drop drop "false." io.write-line
    else
      # Error
      swap "Error: " swap solve-error-message string.concat io.write-line
      drop
    then
  then
;

# ============================================
# CLI Interface
# ============================================

# Run a query from command line arguments
# Usage: ./prog --query "goal(X, Y)"
: run-cli-query ( ClauseDB -- )
  # Check for --query flag with argument
  args.count 3 i.>=
  1 args.at "--query" string.equal? and if
    2 args.at
    # Stack: ClauseDB query-string
    swap run-query-from-string
  else
    # Any other invocation prints usage (including --help, -h, or no args)
    drop print-query-usage
  then
;

# Execute a query string against a clause database
: run-query-from-string ( String ClauseDB -- )
  swap parse-query-string
  # Stack: ClauseDB GoalList success?
  if
    # Stack: ClauseDB GoalList
    over swap          # Stack: ClauseDB ClauseDB GoalList
    swap run-query-all # Stack: ClauseDB SolveResult
    swap               # Stack: SolveResult ClauseDB
    print-all-solutions
  else
    drop drop "Error: Failed to parse query" io.write-line
  then
;

: print-query-usage ( -- )
  "Usage: <program> --query \"goal(X, Y)\"" io.write-line
  "" io.write-line
  "Options:" io.write-line
  "  --query <query>  Execute a Prolog query" io.write-line
  "  --help, -h       Show this help" io.write-line
;
