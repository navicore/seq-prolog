# Runtime Query Execution for Compiled SeqProlog Programs
#
# Provides query parsing and execution for compiled binaries.
# Generated programs include this module and call run-cli-query.

include "../parser"
include "solve"

# ============================================
# Query Variable Tracking
# ============================================

# Extract variables from a term, adding to VarMap
# Uses VarMap from solve.seq (already included)
: extract-vars-from-term ( Term VarMap -- VarMap )
  over tvar? if
    # Variable - add to map if not already present
    over tvar-name over vm-lookup
    0 i.< if
      # Not in map - add it
      over tvar-name
      2 pick tvar-id
      rot
      vm-cons
      nip  # drop original term
    else
      # Already in map - keep as is
      nip
    then
  else
    over tcompound? if
      # Compound - recurse into args
      over tcompound-args
      swap extract-vars-from-termlist
      nip
    else
      # Atom/int/etc - no variables
      nip
    then
  then
;

# Extract variables from a term list
: extract-vars-from-termlist ( TermList VarMap -- VarMap )
  over tlnil? if
    nip
  else
    over tlcar
    over extract-vars-from-term
    # Stack: termlist old-map new-map
    nip  # drop old map
    swap tlcdr swap
    extract-vars-from-termlist
  then
;

# Extract variables from a goal list
: extract-vars-from-goals ( GoalList VarMap -- VarMap )
  over gnull? if
    nip
  else
    over gcar
    over extract-vars-from-term
    # Stack: goals old-map new-map
    nip  # drop old map
    swap gcdr swap
    extract-vars-from-goals
  then
;

# ============================================
# Query Parsing
# ============================================

# Parse a query string into a GoalList and extract query variables
# Returns (GoalList VarMap Bool) - goals, variable map, success
: parse-query-string ( String -- GoalList VarMap Bool )
  # Tokenize the input
  tokenize

  # Parse as goals (handles comma-separated) with fresh variable counter
  0 parse-goals-with-counter
  drop  # drop counter

  # Check if parse succeeded
  dup parse-ok-term? if
    parse-term-value
    # Convert term to goal list
    term-to-goals
    # Extract query variables
    dup vm-empty extract-vars-from-goals
    true
  else
    drop gnull vm-empty false
  then
;

# ============================================
# Result Printing (Prolog format)
# ============================================

# Lookup variable name by ID in VarMap
# Returns empty string if not found
: vm-lookup-name ( Int VarMap -- String )
  dup vm-empty? if
    drop drop ""
  else
    dup vm-id
    2 pick i.= if
      nip vm-name
    else
      vm-rest vm-lookup-name
    then
  then
;

# Print a substitution's variable bindings, filtered by query vars
# Shows original variable names instead of IDs
# New approach: iterate through query vars, look up each in subst
: print-bindings-filtered ( Subst VarMap -- )
  # Stack: subst varmap (1=subst, 0=varmap)
  over subst-empty? if
    drop drop "true." io.write-line
  else
    dup vm-empty? if
      # No query vars - just say true
      drop drop "true." io.write-line
    else
      # Iterate through query vars in VarMap
      false print-query-vars-loop
      if
        "." io.write-line
      else
        "true." io.write-line
      then
    then
  then
;

# Iterate through VarMap entries, print binding for each
# Stack: subst varmap printed-any
: print-query-vars-loop ( Subst VarMap Bool -- Bool )
  over vm-empty? if
    # Done - return printed-any
    nip nip
  else
    # Get this query var's id
    over vm-id
    # Stack: subst varmap printed-any id

    # Look up id in substitution
    # subst-lookup expects (Int Subst -- Bool Term)
    3 pick  # get subst
    # Stack: subst varmap printed-any id subst
    subst-lookup
    # Stack: subst varmap printed-any Bool Term (subst-lookup returns Bool Term with Term on top)
    swap if
      # Found binding - print it
      # Stack: subst varmap printed-any Term
      # First apply substitution to resolve variable chains
      3 pick apply-subst  # Stack: subst varmap printed-any ResolvedTerm
      2 pick vm-name  # get var name from varmap
      # Stack: subst varmap printed-any ResolvedTerm name
      " = " string.concat
      swap term-to-string string.concat
      io.write-line
      # Stack: subst varmap printed-any
      drop true  # we printed something
      # Stack: subst varmap true
      swap vm-rest swap  # advance to next varmap entry
      # Stack: subst rest-varmap true
      print-query-vars-loop
    else
      # Not found - skip this var (drop dummy Term)
      drop
      # Stack: subst varmap printed-any
      swap vm-rest swap  # advance to next varmap entry
      # Stack: subst rest-varmap printed-any
      print-query-vars-loop
    then
  then
;

# Legacy print-bindings for backwards compatibility (shows all vars with IDs)
: print-bindings ( Subst -- )
  dup subst-empty? if
    drop "true." io.write-line
  else
    print-bindings-loop
    "." io.write-line
  then
;

: print-bindings-loop ( Subst -- )
  dup subst-empty? if
    drop
  else
    dup subst-binding
    dup binding-var-id int->string
    " = " string.concat
    swap binding-value term-to-string string.concat
    io.write-line
    subst-parent print-bindings-loop
  then
;

# Print solve result in Prolog format (single solution)
: print-solve-result ( SolveResult -- )
  dup solve-success? if
    solve-success-subst print-bindings
  else
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

# Print all solutions using ChoiceStack for backtracking
: print-all-solutions ( SolveResult ChoiceStack -- )
  over solve-success? if
    swap solve-success-subst print-bindings
    # Stack: cs
    solve-next
    # Stack: result cs
    print-all-solutions
  else
    drop  # drop cs
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

# ============================================
# JSON Output Support
# ============================================

# Escape special characters in strings for JSON output (RFC 8259).
# Escapes: backslash, double quote, backspace, form feed, newline, tab, CR.
# Note: Uses the same char-at indexing pattern as codegen.seq's escape-string-loop.
# Multibyte UTF-8 characters pass through; Seq's string primitives handle encoding.

# Handle backspace, form feed, or pass through for remaining characters
: json-escape-control-or-passthrough ( Int -- String )
  dup 8 i.= if
    drop 92 char->string 98 char->string string.concat
  else dup 12 i.= if
    drop 92 char->string 102 char->string string.concat
  else
    char->string
  then then
;

: json-escape-string-loop ( String Int String -- String )
  # Stack: input pos acc
  2 pick string.length 2 pick i.<= if
    # pos >= length: done, return accumulator
    nip nip
  else
    # Get char at input[pos]
    2 pick 2 pick string.char-at
    dup 92 i.= if
      # Backslash (92) -> escape
      drop 92 char->string 92 char->string string.concat
      string.concat swap 1 i.add swap json-escape-string-loop
    else dup 34 i.= if
      # Double quote (34) -> escape
      drop 92 char->string 34 char->string string.concat
      string.concat swap 1 i.add swap json-escape-string-loop
    else dup 10 i.= if
      # Newline (10) -> \n
      drop 92 char->string 110 char->string string.concat
      string.concat swap 1 i.add swap json-escape-string-loop
    else dup 9 i.= if
      # Tab (9) -> \t
      drop 92 char->string 116 char->string string.concat
      string.concat swap 1 i.add swap json-escape-string-loop
    else dup 13 i.= if
      # Carriage return (13) -> \r
      drop 92 char->string 114 char->string string.concat
      string.concat swap 1 i.add swap json-escape-string-loop
    else
      # Backspace (8) -> \b, form feed (12) -> \f, else pass through
      json-escape-control-or-passthrough
      string.concat swap 1 i.add swap json-escape-string-loop
    then then then then then
  then
;

: json-escape-string ( String -- String )
  0 "" json-escape-string-loop ;

# Convert a resolved Term to its JSON string representation
: term-to-json ( Term -- String )
  dup tatom? if
    dup tatom-name "true" string.equal? if
      drop "true"
    else dup tatom-name "false" string.equal? if
      drop "false"
    else dup tempty-list? if
      drop "[]"
    else
      # Regular atom -> JSON string
      tatom-name json-escape-string
      "\"" swap string.concat "\"" string.concat
    then then then
  else
    dup tint? if
      tint-value int->string
    else
      dup tfloat? if
        tfloat-value float->string
      else
        dup tvar? if
          # Unbound variable -> null
          drop "null"
        else
          dup tproper-list? if
            # Proper list -> JSON array
            "[" swap json-list-contents string.concat
            "]" string.concat
          else
            # Compound or improper list -> Prolog notation as string
            term-to-string json-escape-string
            "\"" swap string.concat "\"" string.concat
          then
        then
      then
    then
  then
;

# Serialize elements of a proper Prolog list as comma-separated JSON
: json-list-contents ( Term -- String )
  dup tempty-list? if
    drop ""
  else
    dup tlist-head term-to-json
    swap tlist-tail
    dup tempty-list? if
      drop
    else
      ", " swap json-list-contents string.concat string.concat
    then
  then
;

# Build a JSON object string from variable bindings
# Iterates VarMap, looks up each variable in Subst, serializes with term-to-json
: json-bindings ( Subst VarMap -- String )
  over subst-empty? if
    drop drop "{}"
  else
    dup vm-empty? if
      drop drop "{}"
    else
      "{" json-bindings-loop "}" string.concat
    then
  then
;

# Accumulates "key": value pairs into a JSON object body
: json-bindings-loop ( Subst VarMap String -- String )
  over vm-empty? if
    # Done - return accumulated string
    nip nip
  else
    # Get this query var's id
    over vm-id
    # Stack: subst varmap acc id

    # Look up id in substitution
    3 pick subst-lookup
    # Stack: subst varmap acc Bool Term
    swap if
      # Found binding - resolve and serialize
      # Stack: subst varmap acc Term
      3 pick apply-subst  # Stack: subst varmap acc ResolvedTerm
      2 pick vm-name      # Stack: subst varmap acc ResolvedTerm name
      # Build "name": value
      json-escape-string
      "\"" swap string.concat "\": " string.concat
      swap term-to-json string.concat
      # Stack: subst varmap acc pair-string
      # If acc is just "{" (first entry), concat directly; otherwise add comma
      over "{" string.equal? if
        string.concat
      else
        swap ", " string.concat swap string.concat
      then
      # Stack: subst varmap new-acc
      swap vm-rest swap
      json-bindings-loop
    else
      # Not found - skip this var
      drop
      # Stack: subst varmap acc
      swap vm-rest swap
      json-bindings-loop
    then
  then
;

# Check if --format json was specified (at arg positions 3 and 4)
: format-json? ( -- Bool )
  args.count 5 i.>=
  3 args.at "--format" string.equal? and
  4 args.at "json" string.equal? and
;

# JSON entry point for --query (single solution)
: run-query-from-string-json ( String ClauseDB -- )
  swap parse-query-string
  # Stack: ClauseDB GoalList VarMap success?
  if
    rot                # Stack: GoalList VarMap ClauseDB
    rot                # Stack: VarMap ClauseDB GoalList
    swap               # Stack: VarMap GoalList ClauseDB
    run-query-offset   # Stack: VarMap SolveResult
    swap               # Stack: SolveResult VarMap
    json-single-result
  else
    drop drop drop
    "{\"error\": \"Failed to parse query\"}" io.write-line
  then
;

# Print a single result in JSON format
: json-single-result ( SolveResult VarMap -- )
  over solve-success? if
    swap solve-success-subst swap json-bindings
    "{\"solutions\": [" swap string.concat
    "], \"exhausted\": false}" string.concat
    io.write-line
  else
    drop
    dup solve-failure? if
      drop
      "{\"solutions\": [], \"exhausted\": true}" io.write-line
    else
      solve-error-message json-escape-string
      "{\"error\": \"" swap string.concat "\"}" string.concat
      io.write-line
    then
  then
;

# JSON entry point for --query-all (all solutions)
: run-query-all-from-string-json ( String ClauseDB -- )
  swap parse-query-string
  # Stack: ClauseDB GoalList VarMap success?
  if
    rot                # Stack: GoalList VarMap ClauseDB
    rot                # Stack: VarMap ClauseDB GoalList
    swap               # Stack: VarMap GoalList ClauseDB
    run-query-all      # Stack: VarMap SolveResult ChoiceStack
    rot                # Stack: SolveResult ChoiceStack VarMap
    json-all-results
  else
    drop drop drop
    "{\"error\": \"Failed to parse query\"}" io.write-line
  then
;

# Print all results in JSON format
: json-all-results ( SolveResult ChoiceStack VarMap -- )
  2 pick solve-success? if
    # Collect all solutions recursively into a comma-separated string
    json-collect-all
    "{\"solutions\": [" swap string.concat
    "], \"exhausted\": true}" string.concat
    io.write-line
  else
    drop drop  # drop cs varmap
    dup solve-failure? if
      drop
      "{\"solutions\": [], \"exhausted\": true}" io.write-line
    else
      solve-error-message json-escape-string
      "{\"error\": \"" swap string.concat "\"}" string.concat
      io.write-line
    then
  then
;

# Recursively collect all solutions into a comma-separated string of JSON objects.
# Uses the call stack for accumulation: each recursive call returns the rest,
# and we prepend the current solution with a comma separator.
# Note: Uses unbounded recursion â€” one stack frame per solution. Suitable for
# typical Prolog result sets but may overflow on thousands of solutions.
: json-collect-all ( SolveResult ChoiceStack VarMap -- String )
  2 pick solve-success? if
    # Get current solution's bindings as JSON object string
    2 pick solve-success-subst
    over json-bindings
    # Stack: result cs varmap bindings-str

    # Rearrange to call solve-next on ChoiceStack
    swap        # Stack: result cs bindings-str varmap
    rot         # Stack: result bindings-str varmap cs
    solve-next  # Stack: result bindings-str varmap new-result new-cs
    rot         # Stack: result bindings-str new-result new-cs varmap

    # Recurse to collect remaining solutions
    json-collect-all
    # Stack: result bindings-str rest-string

    # Combine: if rest is empty, just bindings; otherwise bindings + ", " + rest
    dup string.empty? if
      drop nip
    else
      swap ", " string.concat swap string.concat
      nip
    then
  else
    # No more solutions - return empty string
    drop drop drop ""
  then
;

# ============================================
# CLI Interface
# ============================================

# Run a query from command line arguments
# Usage: ./prog --query "goal(X, Y)"
#        ./prog --query-all "goal(X, Y)"
: run-cli-query ( ClauseDB -- )
  # Check for --query or --query-all flag with argument
  args.count 3 i.>=
  1 args.at "--query" string.equal? and if
    2 args.at
    # Stack: ClauseDB query-string
    swap
    format-json? if
      run-query-from-string-json
    else
      run-query-from-string
    then
  else
    args.count 3 i.>=
    1 args.at "--query-all" string.equal? and if
      2 args.at
      # Stack: ClauseDB query-string
      swap
      format-json? if
        run-query-all-from-string-json
      else
        run-query-all-from-string
      then
    else
      # Any other invocation prints usage (including --help, -h, or no args)
      drop print-query-usage
    then
  then
;

# Execute a query string against a clause database
# Uses solve-first to avoid infinite loops with recursive rules
: run-query-from-string ( String ClauseDB -- )
  swap parse-query-string
  # Stack: ClauseDB GoalList VarMap success?
  if
    # Stack: ClauseDB GoalList VarMap
    rot                # Stack: GoalList VarMap ClauseDB
    rot                # Stack: VarMap ClauseDB GoalList
    swap               # Stack: VarMap GoalList ClauseDB
    run-query-offset   # Stack: VarMap SolveResult
    swap               # Stack: SolveResult VarMap
    print-single-result-filtered
  else
    drop drop drop "Error: Failed to parse query" io.write-line
  then
;

# Execute a query string and enumerate all solutions
: run-query-all-from-string ( String ClauseDB -- )
  swap parse-query-string
  # Stack: ClauseDB GoalList VarMap success?
  if
    # Stack: ClauseDB GoalList VarMap
    rot                # Stack: GoalList VarMap ClauseDB
    rot                # Stack: VarMap ClauseDB GoalList
    swap               # Stack: VarMap GoalList ClauseDB
    run-query-all      # Stack: VarMap SolveResult ChoiceStack
    rot                # Stack: SolveResult ChoiceStack VarMap
    print-all-results-filtered
  else
    drop drop drop "Error: Failed to parse query" io.write-line
  then
;

# Print all solutions filtered by query variables
# Stack: SolveResult ChoiceStack VarMap
: print-all-results-filtered ( SolveResult ChoiceStack VarMap -- )
  2 pick solve-success? if
    # Print this solution
    2 pick solve-success-subst
    over print-bindings-filtered
    # Stack: result cs varmap
    rot drop           # drop old result
    # Stack: cs varmap
    swap solve-next    # Stack: varmap new-result new-cs
    rot                # Stack: new-result new-cs varmap
    print-all-results-filtered
  else
    # No more solutions
    drop               # drop varmap
    drop               # drop cs
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

# Run query with offset counter to avoid collision with query variable IDs
# Query variables are assigned IDs 0, 1, 2, etc.
# Clause renaming starts at 1000 to avoid collisions.
: run-query-offset ( GoalList ClauseDB -- SolveResult )
  # run-query handles the setup internally
  run-query
;

# Print a single result with variable names (for use with solve-first)
: print-single-result-filtered ( SolveResult VarMap -- )
  over solve-success? if
    swap solve-success-subst swap print-bindings-filtered
  else
    drop
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

# Legacy print-single-result for backwards compatibility
: print-single-result ( SolveResult -- )
  dup solve-success? if
    solve-success-subst print-bindings
  else
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

: print-query-usage ( -- )
  "Usage: <program> --query \"goal(X, Y)\" [--format json]" io.write-line
  "       <program> --query-all \"goal(X, Y)\" [--format json]" io.write-line
  "" io.write-line
  "Options:" io.write-line
  "  --query <query>      Execute a Prolog query (first solution)" io.write-line
  "  --query-all <query>  Execute a Prolog query (all solutions)" io.write-line
  "  --format json        Output results as JSON" io.write-line
  "  --help, -h           Show this help" io.write-line
  "" io.write-line
  "Note: --query-all may loop on recursive rules (e.g. ancestor)." io.write-line
  "Use --query for safe first-solution mode with recursive predicates." io.write-line
;
