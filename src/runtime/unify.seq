# Unification for SeqProlog
#
# Implements Robinson's unification algorithm with occurs check.
# Returns UnifyResult: UnifyOk { subst } | UnifyFail

include "../term"

# ============================================
# Dereference: Follow variable bindings
# ============================================

# Follow substitution chain to find actual value
# If term is a variable and bound in subst, recursively dereference
# Preserves Subst on stack for callers that need it
: deref ( Term Subst -- Term Subst )
  over tvar? if
    # Variable - look up in substitution
    over tvar-id over subst-lookup
    # Stack: term subst found? value
    swap if
      # Found binding - replace term with value and recurse
      # Stack: term subst value
      rot drop  # Stack: subst value
      swap      # Stack: value subst
      deref     # Recursively dereference
    else
      # Not found - keep original variable
      drop  # drop dummy value from subst-lookup
    then
  else
    # Not a variable - return unchanged
  then
;

# ============================================
# Occurs Check
# ============================================

# Check if variable ID occurs in term (prevents infinite terms)
: occurs-in? ( Int Term Subst -- Bool )
  # First dereference the term
  deref
  # Stack: var_id term subst
  over tvar? if
    # Stack: var_id term subst
    drop tvar-id i.=
  else
    over tcompound? if
      # Stack: var_id term subst
      swap tcompound-args swap occurs-in-termlist?
    else
      over tlist? if
        # Stack: var_id term subst
        over tlist-head
        # Stack: var_id term subst head
        3 pick swap 2 pick occurs-in? if
          drop drop drop true
        else
          # Stack: var_id term subst
          swap tlist-tail swap occurs-in?
        then
      else
        drop drop drop false
      then
    then
  then
;

: occurs-in-termlist? ( Int TermList Subst -- Bool )
  over tlnil? if
    drop drop drop false
  else
    over tlcar
    3 pick swap 2 pick occurs-in? if
      drop drop drop true
    else
      swap tlcdr swap occurs-in-termlist?
    then
  then
;

# ============================================
# Main Unification
# ============================================

# Unify two terms under a substitution
# Returns UnifyResult
: unify ( Term Term Subst -- UnifyResult )
  # Input: t1 t2 subst
  # Dereference t2 first
  dup                  # t1 t2 subst subst
  rot                  # t1 subst subst t2
  swap deref           # t1 subst t2' subst
  drop                 # t1 subst t2'
  # Dereference t1
  rot                  # subst t2' t1
  rot                  # t2' t1 subst
  dup                  # t2' t1 subst subst
  rot                  # t2' subst subst t1
  swap deref           # t2' subst t1' subst
  drop                 # t2' subst t1'
  # Rearrange to t1' t2' subst
  rot                  # subst t1' t2'
  rot                  # t1' t2' subst

  # Both are variables?
  # Stack: t1 t2 subst (indices: 0=subst 1=t2 2=t1, subst is on top!)
  2 pick tvar? 2 pick tvar? and if
    # Same variable?
    2 pick tvar-id 2 pick tvar-id i.= if
      swap drop nip make-unify-ok  # keep subst, drop t1 t2
    else
      # Bind first to second: subst-bind(t1.id, t2, subst)
      rot tvar-id rot rot subst-bind make-unify-ok
    then
  else
    # t1 is variable?
    2 pick tvar? if
      # Occurs check: check if t1's id occurs in t2
      # Stack: t1 t2 subst
      2 pick tvar-id 2 pick 2 pick occurs-in? if
        drop drop drop make-unify-fail
      else
        # Bind t1 to t2
        rot tvar-id rot rot subst-bind make-unify-ok
      then
    else
      # t2 is variable?
      over tvar? if
        # Occurs check: check if t2's id occurs in t1
        # Stack: t1 t2 subst
        over tvar-id 3 pick 2 pick occurs-in? if
          # Stack after occurs-in?: t1 t2 subst (with t2's id consumed)
          drop drop drop make-unify-fail
        else
          # Bind t2 to t1
          swap tvar-id swap rot swap subst-bind make-unify-ok
        then
      else
        # Neither is variable - must be same structure
        unify-structures
      then
    then
  then
;

# Unify non-variable terms
: unify-structures ( Term Term Subst -- UnifyResult )
  # Both atoms?
  # Stack: t1 t2 subst (indices: 0=subst 1=t2 2=t1, subst is on top!)
  2 pick tatom? 2 pick tatom? and if
    2 pick tatom-name 2 pick tatom-name string.equal? if
      swap drop nip make-unify-ok  # keep subst (on top), drop t1 t2
    else
      drop drop drop make-unify-fail
    then
  else
    # Both integers?
    2 pick tint? 2 pick tint? and if
      2 pick tint-value 2 pick tint-value i.= if
        swap drop nip make-unify-ok  # keep subst, drop t1 t2
      else
        drop drop drop make-unify-fail
      then
    else
      # Both floats?
      2 pick tfloat? 2 pick tfloat? and if
        2 pick tfloat-value 2 pick tfloat-value f.= if
          swap drop nip make-unify-ok  # keep subst, drop t1 t2
        else
          drop drop drop make-unify-fail
        then
      else
        # Both compounds?
        2 pick tcompound? 2 pick tcompound? and if
          # Same functor?
          2 pick tcompound-functor 2 pick tcompound-functor string.equal? if
            # Same arity?
            2 pick tcompound-args tllen 2 pick tcompound-args tllen i.= if
              # Unify arguments
              rot tcompound-args rot tcompound-args rot unify-termlists
            else
              drop drop drop make-unify-fail
            then
          else
            drop drop drop make-unify-fail
          then
        else
          # Both lists?
          2 pick tlist? 2 pick tlist? and if
            # Unify heads
            2 pick tlist-head 2 pick tlist-head 2 pick unify
            # Stack: t1 t2 Subst UnifyResult
            dup unify-ok? if
              unify-ok-subst
              # Stack: t1 t2 Subst NewSubst
              nip  # drop old Subst (at index 1)
              # Stack: t1 t2 NewSubst
              rot tlist-tail  # Stack: t2 NewSubst tail1
              rot tlist-tail  # Stack: NewSubst tail1 tail2
              rot             # Stack: tail1 tail2 NewSubst
              unify
            else
              nip nip nip  # Drop t1 t2 Subst, keep UnifyResult
            then
          else
            # Check empty list atoms
            2 pick tempty-list? 2 pick tempty-list? and if
              swap drop nip make-unify-ok  # keep subst, drop t1 t2
            else
              drop drop drop make-unify-fail
            then
          then
        then
      then
    then
  then
;

# Unify two term lists element by element
: unify-termlists ( TermList TermList Subst -- UnifyResult )
  # Both empty?
  2 pick tlnil? 2 pick tlnil? and if
    nip nip make-unify-ok
  else
    # One empty, other not?
    2 pick tlnil? 2 pick tlnil? or if
      drop drop drop make-unify-fail
    else
      # Unify first elements
      2 pick tlcar
      2 pick tlcar
      2 pick
      unify
      # Stack: l1 l2 Subst UnifyResult
      dup unify-ok? if
        unify-ok-subst
        # Stack: l1 l2 Subst NewSubst
        nip  # drop old Subst (at index 1)
        # Stack: l1 l2 NewSubst
        rot tlcdr    # Stack: l2 NewSubst rest1
        rot tlcdr    # Stack: NewSubst rest1 rest2
        rot          # Stack: rest1 rest2 NewSubst
        unify-termlists
      else
        nip nip nip  # Drop l1 l2 Subst, keep UnifyResult
      then
    then
  then
;

# ============================================
# Apply Substitution
# ============================================

# Apply substitution to term (ground out variables where possible)
: apply-subst ( Term Subst -- Term )
  over tvar? if
    over tvar-id over subst-lookup
    # Stack: Term Subst Bool BoundTerm
    swap if
      # Found binding - resolve recursively with same substitution
      # Stack: Term Subst BoundTerm
      rot drop  # Subst BoundTerm (drop original Term)
      swap      # BoundTerm Subst
      apply-subst
    else
      # Not bound, keep original variable
      # Stack: Term Subst DummyTerm
      drop drop
    then
  else
    over tcompound? if
      over tcompound-functor
      2 pick tcompound-args 2 pick apply-subst-termlist
      3 pick tcompound-span tcompound-at
      nip nip
    else
      over tlist? if
        over tlist-head over apply-subst
        2 pick tlist-tail 2 pick apply-subst
        3 pick tlist-span tlist-at
        nip nip
      else
        # Atom, int, float - return as-is
        drop
      then
    then
  then
;

: apply-subst-termlist ( TermList Subst -- TermList )
  over tlnil? if
    drop
  else
    over tlcar over apply-subst
    rot tlcdr rot apply-subst-termlist
    tlcons
  then
;
