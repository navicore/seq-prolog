# ChoiceStack-Threaded Solve Engine for SeqProlog
#
# Uses explicit ChoiceStack for backtracking.
# ChoicePoints save goals, untried clauses, and substitution state.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.
# See: https://github.com/navicore/seq-prolog/issues/5

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# ChoiceStack-Threaded Solver
# ============================================
#
# Uses explicit ChoiceStack for backtracking instead of CPS closures.
# ChoicePoints save state needed to try alternative clauses.

# ============================================
# Entry Points
# ============================================

# run-query: Execute a query and return first solution only
: run-query ( GoalList ClauseDB -- SolveResult )
  swap subst-empty rot 1000 cpnil solve
  drop  # drop ChoiceStack
;

# run-query-all: Execute a query and return first solution + ChoiceStack for enumeration
: run-query-all ( GoalList ClauseDB -- SolveResult ChoiceStack )
  swap subst-empty rot 1000 cpnil solve
;

# ============================================
# Core Solver
# ============================================

# solve: Main solver with ChoiceStack threading
# Stack: goals subst db counter choicestack
# Returns: SolveResult ChoiceStack
: solve ( GoalList Subst ClauseDB Int ChoiceStack -- SolveResult ChoiceStack )
  # Check for empty goals
  4 pick gnull? if
    # No goals - SUCCESS!
    # Stack: goals subst db counter cs
    # Return SolveSuccess with subst, keep cs
    3 pick make-solve-success
    # Stack: goals subst db counter cs result
    5 roll drop  # drop goals
    4 roll drop  # drop subst
    3 roll drop  # drop db
    2 roll drop  # drop counter
    # Stack: cs result
    swap         # Stack: result cs
  else
    # Have goals - solve first one
    4 pick gcar  # Stack: goals subst db counter cs goal

    dup builtin? if
      solve-builtin
    else
      # User-defined predicate - find matching clauses
      # Stack: goals subst db counter cs goal
      3 pick           # get db
      matching-clauses # Stack: goals subst db counter cs matching
      try-clauses
    then
  then
;

# ============================================
# Built-in Handling
# ============================================

# solve-builtin: Handle built-in predicates with ChoiceStack
# Stack: goals subst db counter cs goal
: solve-builtin ( GoalList Subst ClauseDB Int ChoiceStack Term -- SolveResult ChoiceStack )
  # Execute the builtin: goal subst -> UnifyResult
  4 pick             # get subst
  exec-builtin       # Stack: goals subst db counter cs result (6 items)

  dup unify-ok? if
    unify-ok-subst   # Stack: goals subst db counter cs new-subst (6 items)
    # idx: 5=goals 4=subst 3=db 2=counter 1=cs 0=new-subst

    5 pick gcdr      # rest-goals (7 items)
    swap             # Stack: goals subst db counter cs rest-goals new-subst (7 items)

    # Copy db counter cs
    # Stack (7): goals subst db counter cs rest-goals new-subst
    # idx: 6=goals 5=subst 4=db 3=counter 2=cs 1=rest-goals 0=new-subst
    4 pick           # db (8 items)
    4 pick           # counter (9 items)
    4 pick           # cs (10 items)
    # Stack (10): goals subst db counter cs rest-goals new-subst db' counter' cs'
    # Top 5 form: rest-goals new-subst db' counter' cs'

    # Drop lower 5 items
    9 roll drop   # drop goals
    8 roll drop   # drop subst
    7 roll drop   # drop db
    6 roll drop   # drop counter
    5 roll drop   # drop cs
    # Stack: rest-goals new-subst db' counter' cs' (5 items)
    solve
  else
    # Builtin failed - backtrack
    # Stack: goals subst db counter cs result (6 items)
    drop          # drop result
    4 roll drop   # drop goals
    3 roll drop   # drop subst
    2 roll drop   # drop db
    swap drop     # drop counter, keep cs
    # Stack: cs
    solve-next
  then
;

# ============================================
# Clause Matching with Backtracking
# ============================================

# try-clauses: Try each matching clause with ChoiceStack
# Stack: goals subst db counter cs matching
: try-clauses ( GoalList Subst ClauseDB Int ChoiceStack ClauseDB -- SolveResult ChoiceStack )
  dup db-empty? if
    # No more clauses - backtrack via solve-next
    # Stack: goals subst db counter cs matching
    drop          # drop matching
    4 roll drop   # drop goals
    3 roll drop   # drop subst
    2 roll drop   # drop db
    swap drop     # drop counter, keep cs
    # Stack: cs
    solve-next
  else
    try-first-clause
  then
;

# try-first-clause: Try unifying with first clause
# Stack: goals subst db counter cs matching
: try-first-clause ( GoalList Subst ClauseDB Int ChoiceStack ClauseDB -- SolveResult ChoiceStack )
  # Get first clause and rename
  dup db-first       # Stack: goals subst db counter cs matching clause (7)
  3 pick             # get counter (8)
  rename-clause      # Stack: goals subst db counter cs matching renamed new-counter (8)

  # Unify goal with clause head
  over clause-head   # head (9)
  8 pick gcar        # first goal (10)
  8 pick             # subst (11)
  unify
  # Stack: goals subst db counter cs matching renamed new-counter result (9)

  dup unify-ok? if
    unify-ok-subst
    # Stack: goals subst db counter cs matching renamed new-counter new-subst (9)
    unify-success
  else
    # Unification failed - try next clause
    # Stack: goals subst db counter cs matching renamed new-counter result (9)
    drop             # drop result (8)
    drop             # drop new-counter (7)
    drop             # drop renamed (6)
    db-rest          # remaining clauses
    try-clauses
  then
;

# ============================================
# Unification Success with Choice Point Creation
# ============================================

# unify-success: Unification succeeded, optionally push choice point, continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst (9 items)
: unify-success ( GoalList Subst ClauseDB Int ChoiceStack ClauseDB Clause Int Subst -- SolveResult ChoiceStack )
  # Indices: 8=goals 7=subst 6=db 5=counter 4=cs 3=matching 2=renamed 1=new-counter 0=new-subst

  # Build combined goals: clause-body ++ rest-of-goals
  2 pick clause-body   # body from renamed (10 items)
  9 pick gcdr          # rest of original goals (11 items)
  gappend              # combined (10 items)
  # Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined

  # Check if matching has remaining clauses (alternatives)
  4 pick db-rest db-empty? if
    # No alternatives - no choice point needed
    # solve needs: combined new-subst db new-counter cs
    unify-success-no-cp
  else
    # Has alternatives - push choice point before solving
    unify-success-with-cp
  then
;

# unify-success-no-cp: No alternative clauses, just continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
: unify-success-no-cp ( GoalList Subst ClauseDB Int ChoiceStack ClauseDB Clause Int Subst GoalList -- SolveResult ChoiceStack )
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined
  # Need: combined new-subst db new-counter cs

  # Copy what we need to top
  1 pick         # new-subst (11)
  8 pick         # db (12)
  4 pick         # new-counter (13)
  8 pick         # cs (14)
  # Stack (14): goals subst db counter cs matching renamed new-counter new-subst combined new-subst' db' new-counter' cs'
  # Top 5: combined new-subst' db' new-counter' cs'

  # Drop lower 9 items
  13 roll drop   # drop goals (13)
  12 roll drop   # drop subst (12)
  11 roll drop   # drop db (11)
  10 roll drop   # drop counter (10)
  9 roll drop    # drop cs (9)
  8 roll drop    # drop matching (8)
  7 roll drop    # drop renamed (7)
  6 roll drop    # drop new-counter (6)
  5 roll drop    # drop new-subst (5)

  # Stack: combined new-subst' db' new-counter' cs' (5 items)
  solve
;

# unify-success-with-cp: Push choice point for alternatives, then continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
: unify-success-with-cp ( GoalList Subst ClauseDB Int ChoiceStack ClauseDB Clause Int Subst GoalList -- SolveResult ChoiceStack )
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined

  # Build choice point: make-cp ( GoalList ClauseDB ClauseDB Subst Int -- ChoicePoint )
  # Args: original-goals, rest-of-matching, full-db, original-subst, original-counter
  9 pick         # goals -> Stack(11)
  5 pick db-rest # rest-matching -> Stack(12)
  9 pick         # db -> Stack(13)
  11 pick        # subst -> Stack(14)
  10 pick        # counter -> Stack(15)
  make-cp        # -> Stack(11): goals subst db counter cs matching renamed new-counter new-subst combined cp

  # Push cp onto cs: cpcons ( ChoicePoint ChoiceStack -- ChoiceStack )
  6 pick         # cs -> Stack(12)
  cpcons         # -> Stack(11): goals subst db counter cs matching renamed new-counter new-subst combined new-cs
  # Indices: 10=goals 9=subst 8=db 7=counter 6=cs 5=matching 4=renamed 3=new-counter 2=new-subst 1=combined 0=new-cs

  # Need for solve: combined new-subst db new-counter new-cs
  # Copy needed values to top
  1 pick         # combined -> Stack(12)
  3 pick         # new-subst -> Stack(13)
  10 pick        # db -> Stack(14)
  6 pick         # new-counter -> Stack(15)
  4 pick         # new-cs -> Stack(16)
  # Top 5: combined new-subst db new-counter new-cs

  # Drop lower 11
  15 roll drop  14 roll drop  13 roll drop  12 roll drop
  11 roll drop  10 roll drop  9 roll drop   8 roll drop
  7 roll drop   6 roll drop   5 roll drop
  # Stack: combined new-subst db new-counter new-cs (5)
  solve
;

# ============================================
# Backtracking
# ============================================

# solve-next: Backtrack by popping a choice point and trying next clause
# Stack: cs
# Returns: SolveResult ChoiceStack
: solve-next ( ChoiceStack -- SolveResult ChoiceStack )
  dup cpnil? if
    # No more choice points - failure
    drop
    make-solve-failure cpnil
  else
    # Pop top choice point
    dup cpcar       # Stack: cs cp
    swap cpcdr      # Stack: cp rest-cs

    # Extract fields from choice point
    over cp-goals             # Stack: cp rest-cs goals
    2 pick cp-untried-clauses # Stack: cp rest-cs goals untried
    3 pick cp-full-db         # Stack: cp rest-cs goals untried db
    4 pick cp-subst           # Stack: cp rest-cs goals untried db subst
    5 pick cp-var-counter     # Stack: cp rest-cs goals untried db subst counter (7)

    # Rearrange for try-clauses: goals subst db counter cs matching
    # We have: cp rest-cs goals untried db subst counter (7 items)
    # idx:     6  5       4     3       2  1     0

    # Build target stack: goals subst db counter rest-cs untried
    4 pick         # goals -> Stack(8)
    2 pick         # subst -> Stack(9)
    4 pick         # db -> Stack(10)
    3 pick         # counter -> Stack(11)
    9 pick         # rest-cs -> Stack(12)
    8 pick         # untried -> Stack(13)
    # Top 6: goals subst db counter rest-cs untried

    # Drop lower 7
    12 roll drop  11 roll drop  10 roll drop  9 roll drop
    8 roll drop   7 roll drop   6 roll drop
    # Stack: goals subst db counter rest-cs untried (6)
    # This matches: goals subst db counter cs matching
    try-clauses
  then
;
