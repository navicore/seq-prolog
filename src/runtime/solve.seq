# ChoiceStack-Threaded Solve Engine for SeqProlog
#
# Uses explicit ChoiceStack for backtracking.
# ChoicePoints save goals, untried clauses, and substitution state.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.
# See: https://github.com/navicore/seq-prolog/issues/5

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Predicate Index Building
# ============================================

# Extract predicate key from a clause head term
# For compound: "functor/arity", for atom: "atomname/0"
: clause-pred-key ( Clause -- String )
  clause-head
  dup tcompound? if
    dup tcompound-functor
    swap tcompound-args tllen int->string
    "/" swap string.concat swap string.concat
  else
    dup tatom? if
      tatom-name "/0" string.concat
    else
      drop "unknown/0"
    then
  then
;

# Extract predicate key from a goal term
: goal-pred-key ( Term -- String )
  dup tcompound? if
    dup tcompound-functor
    swap tcompound-args tllen int->string
    "/" swap string.concat swap string.concat
  else
    dup tatom? if
      tatom-name "/0" string.concat
    else
      drop "unknown/0"
    then
  then
;

# Extract first-arg key from a clause head (for arg indexing)
# Returns ( String Bool ) -- key and whether it's indexable (non-variable first arg)
: clause-first-arg-key ( Clause -- String Bool )
  clause-head
  dup tcompound? if
    tcompound-args
    dup tlnil? if
      drop "" false
    else
      tlcar
      dup tatom? if
        tatom-name true
      else
        dup tint? if
          tint-value int->string true
        else
          dup tcompound? if
            dup tcompound-functor
            swap tcompound-args tllen int->string
            "/" swap string.concat swap string.concat
            true
          else
            # Variable or other - not indexable
            drop "" false
          then
        then
      then
    then
  else
    # Atom (no args) - not indexable
    drop "" false
  then
;

# Extract first-arg key from a goal term (for lookup)
# Returns ( String Bool ) -- key and whether first arg is ground
: goal-first-arg-key ( Term -- String Bool )
  dup tcompound? if
    tcompound-args
    dup tlnil? if
      drop "" false
    else
      tlcar
      dup tatom? if
        tatom-name true
      else
        dup tint? if
          tint-value int->string true
        else
          dup tcompound? if
            dup tcompound-functor
            swap tcompound-args tllen int->string
            "/" swap string.concat swap string.concat
            true
          else
            # Variable - not ground
            drop "" false
          then
        then
      then
    then
  else
    # Atom - no args
    drop "" false
  then
;

# ============================================
# Index Entry Helpers
# ============================================

# Add clause with ground first arg to a PredicateEntry
# Adds clause to arg_index (under given key) and to all_clauses
: entry-add-indexed ( Clause String PredicateEntry -- PredicateEntry )
  # Stack: clause(2) key(1) entry(0)
  # Step 1: Build new arg_index by adding clause to key's bucket
  dup pred-arg-index       # clause(3) key(2) entry(1) arg-idx(0)
  2 pick                   # clause(4) key(3) entry(2) arg-idx(1) key-copy(0)
  4 pick                   # clause(5) key(4) entry(3) arg-idx(2) key-copy(1) clause-copy(0)
  rot                      # clause(5) key(4) entry(3) key-copy(2) clause-copy(1) arg-idx(0)
  ai-add                   # clause(2) key(1) entry(0) new-arg-idx
  # Step 2: Copy var_clauses (unchanged)
  over pred-var-clauses    # clause(3) key(2) entry(1) new-arg-idx(0) -> over copies entry ->
                           # clause(4) key(3) entry(2) new-arg-idx(1) var-cls(0)
  # Step 3: Build new all_clauses (append clause)
  2 pick pred-all-clauses  # clause(5) key(4) entry(3) new-arg-idx(2) var-cls(1) all-cls(0)
  5 pick swap db-cons      # clause(4) key(3) entry(2) new-arg-idx(1) var-cls(0) new-all
  # Top 3: new-arg-idx(2) var-cls(1) new-all(0) = args for make-pred-entry
  make-pred-entry          # clause(1) key(0) entry -> wait, consumed 3 -> clause(1) key(0) new-pred
  nip nip nip              # new-pred
;

# Add clause with variable first arg to a PredicateEntry
# Adds clause to var_clauses and to all_clauses; arg_index unchanged
: entry-add-to-var ( Clause PredicateEntry -- PredicateEntry )
  # Stack: clause(1) entry(0)
  dup pred-arg-index       # clause(2) entry(1) arg-idx(0)
  # Prepend clause to var_clauses (reversed later by finalize-index)
  2 pick                   # clause(3) entry(2) arg-idx(1) clause-copy(0)
  2 pick pred-var-clauses  # clause(4) entry(3) arg-idx(2) clause-copy(1) var-cls(0)
  db-cons                  # clause(2) entry(1) arg-idx(0) new-var
  # Prepend clause to all_clauses (reversed later by finalize-index)
  3 pick                   # clause(3) entry(2) arg-idx(1) new-var(0) clause-copy2
  3 pick pred-all-clauses  # clause(4) entry(3) arg-idx(2) new-var(1) clause-copy2(0) -> 3 pick copies entry ->
                           # ... all-cls(0)
  db-cons                  # clause(2) entry(1) arg-idx(0) new-var new-all
  # Top 3: arg-idx new-var new-all = args for make-pred-entry
  make-pred-entry          # clause(1) entry(0) new-pred
  nip nip                  # new-pred
;

# Add a clause to a PredicateEntry, routing to arg_index or var_clauses
: pred-entry-add ( Clause PredicateEntry -- PredicateEntry )
  # Stack: clause(1) entry(0)
  swap dup clause-first-arg-key
  # swap: entry(1) clause(0)
  # dup: entry(2) clause(1) clause-copy(0)
  # clause-first-arg-key consumes copy, returns key+bool:
  #   entry(3) clause(2) key(1) indexable?(0)
  if
    # Indexable: entry(2) clause(1) key(0)
    rot                    # clause(2) key(1) entry(0)
    entry-add-indexed
  else
    # Not indexable: entry(2) clause(1) key(0)
    drop                   # entry(1) clause(0)
    swap                   # clause(1) entry(0)
    entry-add-to-var
  then
;

# ============================================
# Predicate Index Helpers
# ============================================

# Replace a predicate entry by key in the index
: pi-replace ( String PredicateEntry PredicateIndex -- PredicateIndex )
  # Stack: key(2) new-entry(1) index(0)
  dup pi-empty? if
    # Not found - just add it
    drop pi-empty pi-cons
  else
    dup pi-key
    3 pick string.equal? if
      # Found it - replace entry, keep rest
      # Stack: key(2) new-entry(1) index(0)
      pi-rest              # key(2) new-entry(1) rest(0)
      pi-cons              # result
    else
      # Not this one - recurse on rest
      # Stack: key(2) new-entry(1) index(0)
      dup pi-rest            # key(3) new-entry(2) index(1) rest(0)
      3 pick                 # key(4) new-entry(3) index(2) rest(1) key-copy(0)
      3 pick                 # key(5) new-entry(4) index(3) rest(2) key-copy(1) new-entry-copy(0)
      rot                    # key(5) new-entry(4) index(3) key-copy(2) new-entry-copy(1) rest(0)
      pi-replace             # key(2) new-entry(1) index(0) rebuilt-rest
      swap dup pi-key        # key(3) new-entry(2) rebuilt-rest(1) index(0) ->
                             # key(4) new-entry(3) rebuilt-rest(2) index(1) this-key(0)
      swap pi-entry          # key(4) new-entry(3) rebuilt-rest(2) this-key(1) this-entry(0)
      rot                    # key(4) new-entry(3) this-key(2) this-entry(1) rebuilt-rest(0)
      pi-cons                # key(1) new-entry(0) rebuilt
      nip nip                # result
    then
  then
;

# Add a clause to the predicate index
: pi-add-clause ( Clause PredicateIndex -- PredicateIndex )
  # Stack: clause(1) pidx(0)
  over clause-pred-key     # clause(2) pidx(1) pred-key(0)
  dup                      # clause(3) pidx(2) pred-key(1) pred-key-copy(0)
  2 pick                   # clause(4) pidx(3) pred-key(2) pred-key-copy(1) pidx-copy(0)
  pi-lookup                # clause(4) pidx(3) pred-key(2) entry(1) found?(0)
  if
    # Found existing entry - add clause to it
    # Stack: clause(3) pidx(2) pred-key(1) entry(0)
    3 roll                 # pidx(2) pred-key(1) entry(0) clause
    swap                   # pidx(2) pred-key(1) clause(0) entry
    pred-entry-add         # pidx(1) pred-key(0) new-entry
    rot                    # pred-key(2) new-entry(1) pidx(0)
    pi-replace             # new-pidx
  else
    # New predicate - create fresh entry and add clause
    # Stack: clause(3) pidx(2) pred-key(1) entry(0) (dummy empty entry)
    drop                   # clause(2) pidx(1) pred-key(0)
    rot                    # pidx(2) pred-key(1) clause(0)
    ai-empty db-empty db-empty make-pred-entry
    # Stack: pidx(2) pred-key(1) clause(0) empty-entry
    pred-entry-add         # pidx(1) pred-key(0) new-entry
    rot                    # pred-key(2) new-entry(1) pidx(0)
    pi-cons                # new-pidx
  then
;

# (db-reverse and ai-reverse-all are defined in term.seq)

# Reverse all clause lists in a PredicateEntry
: pred-entry-reverse ( PredicateEntry -- PredicateEntry )
  dup pred-arg-index ai-reverse-all    # entry new-arg-idx
  over pred-var-clauses db-reverse     # entry new-arg-idx new-var-cls
  rot pred-all-clauses db-reverse      # new-arg-idx new-var-cls new-all-cls
  make-pred-entry
;

# Reverse all clause lists in the entire PredicateIndex
: finalize-index ( PredicateIndex -- PredicateIndex )
  dup pi-empty? if
  else
    dup pi-key
    over pi-entry pred-entry-reverse
    rot pi-rest finalize-index
    pi-cons
  then
;

# ============================================
# Index Building
# ============================================

# Build a full predicate index from a flat ClauseDB
# Uses prepend (O(1)) during building, then reverses all lists
: build-index ( ClauseDB -- PredicateIndex )
  pi-empty build-index-loop finalize-index ;

: build-index-loop ( ClauseDB PredicateIndex -- PredicateIndex )
  swap dup db-empty? if
    drop
  else
    dup db-first           # pidx db clause
    rot                    # db clause pidx
    pi-add-clause          # db new-pidx
    swap db-rest swap      # rest-db new-pidx
    build-index-loop
  then
;

# Look up matching clauses for a goal using the predicate index
# This is the fast replacement for matching-clauses
: index-lookup ( Term PredicateIndex -- ClauseDB )
  # Stack: goal(1) pidx(0)
  over goal-pred-key       # goal(2) pidx(1) pred-key(0)
  dup 2 pick               # goal(4) pidx(3) pred-key(2) pred-key-copy(1) pidx-copy(0)
  pi-lookup                # goal(4) pidx(3) pred-key(2) entry(1) found?(0)
  if
    # Found predicate entry
    # Stack: goal(3) pidx(2) pred-key(1) entry(0)
    nip nip                # goal(1) entry(0)
    swap                   # entry(1) goal(0)
    # If var_clauses is non-empty, use all_clauses for correct clause ordering
    over pred-var-clauses db-empty? if
      # No var clauses - safe to use first-arg index
      goal-first-arg-key   # entry(2) arg-key(1) ground?(0)
      if
        # Ground first arg - look up in arg_index
        over pred-arg-index  # entry(2) arg-key(1) arg-idx(0)
        ai-lookup            # entry(2) found-clauses(1) found?(0)
        if
          nip              # found-clauses (drop entry)
        else
          drop pred-all-clauses  # fallback to all clauses
        then
      else
        # Variable first arg in query - return all_clauses
        drop pred-all-clauses
      then
    else
      # Has var clauses - use all_clauses for correct ordering
      drop pred-all-clauses
    then
  else
    # Predicate not found in index
    # Stack: goal(3) pidx(2) pred-key(1) entry(0)
    drop drop drop drop db-empty
  then
;

# ============================================
# Find Matching Clauses (legacy, kept for reference)
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# ChoiceStack-Threaded Solver
# ============================================
#
# Uses explicit ChoiceStack for backtracking instead of CPS closures.
# ChoicePoints save state needed to try alternative clauses.

# ============================================
# Entry Points
# ============================================

# run-query: Execute a query and return first solution only
: run-query ( GoalList PredicateIndex -- SolveResult )
  swap subst-empty rot 1000 cpnil solve
  drop  # drop ChoiceStack
;

# run-query-all: Execute a query and return first solution + ChoiceStack for enumeration
: run-query-all ( GoalList PredicateIndex -- SolveResult ChoiceStack )
  swap subst-empty rot 1000 cpnil solve
;

# ============================================
# Core Solver
# ============================================

# solve: Main solver with ChoiceStack threading
# Stack: goals subst db counter choicestack
# Returns: SolveResult ChoiceStack
: solve ( GoalList Subst PredicateIndex Int ChoiceStack -- SolveResult ChoiceStack )
  # Check for empty goals
  4 pick gnull? if
    # No goals - SUCCESS!
    # Stack: goals subst db counter cs
    # Return SolveSuccess with subst, keep cs
    3 pick make-solve-success
    # Stack: goals subst db counter cs result
    5 roll drop  # drop goals
    4 roll drop  # drop subst
    3 roll drop  # drop db
    2 roll drop  # drop counter
    # Stack: cs result
    swap         # Stack: result cs
  else
    # Have goals - solve first one
    4 pick gcar  # Stack: goals subst db counter cs goal

    dup builtin? if
      solve-builtin
    else
      # User-defined predicate - find matching clauses via index
      # Stack: goals subst db counter cs goal
      3 pick           # get db (PredicateIndex)
      index-lookup     # Stack: goals subst db counter cs matching
      try-clauses
    then
  then
;

# ============================================
# Built-in Handling
# ============================================

# solve-builtin: Handle built-in predicates with ChoiceStack
# Stack: goals subst db counter cs goal
: solve-builtin ( GoalList Subst PredicateIndex Int ChoiceStack Term -- SolveResult ChoiceStack )
  # Execute the builtin: goal subst -> UnifyResult
  4 pick             # get subst
  exec-builtin       # Stack: goals subst db counter cs result (6 items)

  dup unify-ok? if
    unify-ok-subst   # Stack: goals subst db counter cs new-subst (6 items)
    # idx: 5=goals 4=subst 3=db 2=counter 1=cs 0=new-subst

    5 pick gcdr      # rest-goals (7 items)
    swap             # Stack: goals subst db counter cs rest-goals new-subst (7 items)

    # Copy db counter cs
    # Stack (7): goals subst db counter cs rest-goals new-subst
    # idx: 6=goals 5=subst 4=db 3=counter 2=cs 1=rest-goals 0=new-subst
    4 pick           # db (8 items)
    4 pick           # counter (9 items)
    4 pick           # cs (10 items)
    # Stack (10): goals subst db counter cs rest-goals new-subst db' counter' cs'
    # Top 5 form: rest-goals new-subst db' counter' cs'

    # Drop lower 5 items
    9 roll drop   # drop goals
    8 roll drop   # drop subst
    7 roll drop   # drop db
    6 roll drop   # drop counter
    5 roll drop   # drop cs
    # Stack: rest-goals new-subst db' counter' cs' (5 items)
    solve
  else
    # Builtin failed - backtrack
    # Stack: goals subst db counter cs result (6 items)
    drop          # drop result
    4 roll drop   # drop goals
    3 roll drop   # drop subst
    2 roll drop   # drop db
    swap drop     # drop counter, keep cs
    # Stack: cs
    solve-next
  then
;

# ============================================
# Clause Matching with Backtracking
# ============================================

# try-clauses: Try each matching clause with ChoiceStack
# Stack: goals subst db counter cs matching
: try-clauses ( GoalList Subst PredicateIndex Int ChoiceStack ClauseDB -- SolveResult ChoiceStack )
  dup db-empty? if
    # No more clauses - backtrack via solve-next
    # Stack: goals subst db counter cs matching
    drop          # drop matching
    4 roll drop   # drop goals
    3 roll drop   # drop subst
    2 roll drop   # drop db
    swap drop     # drop counter, keep cs
    # Stack: cs
    solve-next
  else
    try-first-clause
  then
;

# try-first-clause: Try unifying with first clause
# Stack: goals subst db counter cs matching
: try-first-clause ( GoalList Subst PredicateIndex Int ChoiceStack ClauseDB -- SolveResult ChoiceStack )
  # Get first clause and rename
  dup db-first       # Stack: goals subst db counter cs matching clause (7)
  3 pick             # get counter (8)
  rename-clause      # Stack: goals subst db counter cs matching renamed new-counter (8)

  # Unify goal with clause head
  over clause-head   # head (9)
  8 pick gcar        # first goal (10)
  8 pick             # subst (11)
  unify
  # Stack: goals subst db counter cs matching renamed new-counter result (9)

  dup unify-ok? if
    unify-ok-subst
    # Stack: goals subst db counter cs matching renamed new-counter new-subst (9)
    unify-success
  else
    # Unification failed - try next clause
    # Stack: goals subst db counter cs matching renamed new-counter result (9)
    drop             # drop result (8)
    drop             # drop new-counter (7)
    drop             # drop renamed (6)
    db-rest          # remaining clauses
    try-clauses
  then
;

# ============================================
# Unification Success with Choice Point Creation
# ============================================

# unify-success: Unification succeeded, optionally push choice point, continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst (9 items)
: unify-success ( GoalList Subst PredicateIndex Int ChoiceStack ClauseDB Clause Int Subst -- SolveResult ChoiceStack )
  # Indices: 8=goals 7=subst 6=db 5=counter 4=cs 3=matching 2=renamed 1=new-counter 0=new-subst

  # Build combined goals: clause-body ++ rest-of-goals
  2 pick clause-body   # body from renamed (10 items)
  9 pick gcdr          # rest of original goals (11 items)
  gappend              # combined (10 items)
  # Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined

  # Check if matching has remaining clauses (alternatives)
  4 pick db-rest db-empty? if
    # No alternatives - no choice point needed
    # solve needs: combined new-subst db new-counter cs
    unify-success-no-cp
  else
    # Has alternatives - push choice point before solving
    unify-success-with-cp
  then
;

# unify-success-no-cp: No alternative clauses, just continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
: unify-success-no-cp ( GoalList Subst PredicateIndex Int ChoiceStack ClauseDB Clause Int Subst GoalList -- SolveResult ChoiceStack )
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined
  # Need: combined new-subst db new-counter cs

  # Copy what we need to top
  1 pick         # new-subst (11)
  8 pick         # db (12)
  4 pick         # new-counter (13)
  8 pick         # cs (14)
  # Stack (14): goals subst db counter cs matching renamed new-counter new-subst combined new-subst' db' new-counter' cs'
  # Top 5: combined new-subst' db' new-counter' cs'

  # Drop lower 9 items
  13 roll drop   # drop goals (13)
  12 roll drop   # drop subst (12)
  11 roll drop   # drop db (11)
  10 roll drop   # drop counter (10)
  9 roll drop    # drop cs (9)
  8 roll drop    # drop matching (8)
  7 roll drop    # drop renamed (7)
  6 roll drop    # drop new-counter (6)
  5 roll drop    # drop new-subst (5)

  # Stack: combined new-subst' db' new-counter' cs' (5 items)
  solve
;

# unify-success-with-cp: Push choice point for alternatives, then continue solving
# Stack: goals subst db counter cs matching renamed new-counter new-subst combined (10)
: unify-success-with-cp ( GoalList Subst PredicateIndex Int ChoiceStack ClauseDB Clause Int Subst GoalList -- SolveResult ChoiceStack )
  # Indices: 9=goals 8=subst 7=db 6=counter 5=cs 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined

  # Build choice point: make-cp ( GoalList ClauseDB ClauseDB Subst Int -- ChoicePoint )
  # Args: original-goals, rest-of-matching, full-db, original-subst, original-counter
  9 pick         # goals -> Stack(11)
  5 pick db-rest # rest-matching -> Stack(12)
  9 pick         # db -> Stack(13)
  11 pick        # subst -> Stack(14)
  10 pick        # counter -> Stack(15)
  make-cp        # -> Stack(11): goals subst db counter cs matching renamed new-counter new-subst combined cp

  # Push cp onto cs: cpcons ( ChoicePoint ChoiceStack -- ChoiceStack )
  6 pick         # cs -> Stack(12)
  cpcons         # -> Stack(11): goals subst db counter cs matching renamed new-counter new-subst combined new-cs
  # Indices: 10=goals 9=subst 8=db 7=counter 6=cs 5=matching 4=renamed 3=new-counter 2=new-subst 1=combined 0=new-cs

  # Need for solve: combined new-subst db new-counter new-cs
  # Copy needed values to top
  1 pick         # combined -> Stack(12)
  3 pick         # new-subst -> Stack(13)
  10 pick        # db -> Stack(14)
  6 pick         # new-counter -> Stack(15)
  4 pick         # new-cs -> Stack(16)
  # Top 5: combined new-subst db new-counter new-cs

  # Drop lower 11
  15 roll drop  14 roll drop  13 roll drop  12 roll drop
  11 roll drop  10 roll drop  9 roll drop   8 roll drop
  7 roll drop   6 roll drop   5 roll drop
  # Stack: combined new-subst db new-counter new-cs (5)
  solve
;

# ============================================
# Backtracking
# ============================================

# solve-next: Backtrack by popping a choice point and trying next clause
# Stack: cs
# Returns: SolveResult ChoiceStack
: solve-next ( ChoiceStack -- SolveResult ChoiceStack )
  dup cpnil? if
    # No more choice points - failure
    drop
    make-solve-failure cpnil
  else
    # Pop top choice point
    dup cpcar       # Stack: cs cp
    swap cpcdr      # Stack: cp rest-cs

    # Extract fields from choice point
    over cp-goals             # Stack: cp rest-cs goals
    2 pick cp-untried-clauses # Stack: cp rest-cs goals untried
    3 pick cp-full-db         # Stack: cp rest-cs goals untried db
    4 pick cp-subst           # Stack: cp rest-cs goals untried db subst
    5 pick cp-var-counter     # Stack: cp rest-cs goals untried db subst counter (7)

    # Rearrange for try-clauses: goals subst db counter cs matching
    # We have: cp rest-cs goals untried db subst counter (7 items)
    # idx:     6  5       4     3       2  1     0

    # Build target stack: goals subst db counter rest-cs untried
    4 pick         # goals -> Stack(8)
    2 pick         # subst -> Stack(9)
    4 pick         # db -> Stack(10)
    3 pick         # counter -> Stack(11)
    9 pick         # rest-cs -> Stack(12)
    8 pick         # untried -> Stack(13)
    # Top 6: goals subst db counter rest-cs untried

    # Drop lower 7
    12 roll drop  11 roll drop  10 roll drop  9 roll drop
    8 roll drop   7 roll drop   6 roll drop
    # Stack: goals subst db counter rest-cs untried (6)
    # This matches: goals subst db counter cs matching
    try-clauses
  then
;
