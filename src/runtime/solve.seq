# Solve Engine for SeqProlog
#
# Simple depth-first solver that returns first solution.
# TODO: Add weave-based backtracking for multiple solutions.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Renaming (Simple counter-based)
# ============================================
# For now, use simple counter-based renaming without VarMap.
# This means same-named variables in head/body will get different IDs.
# TODO: Add VarMap-based renaming for correct variable sharing.

: rename-var ( Term Int -- Term Int )
  # Input: var counter
  # Output: new-var counter+1
  # Stack: var counter
  dup                    # var counter counter
  1 i.+                  # var counter counter+1
  rot                    # counter counter+1 var
  tvar-name              # counter counter+1 "name"
  rot                    # counter+1 "name" counter
  no-span tvar-at        # counter+1 new-var
  swap                   # new-var counter+1
;

: rename-term ( Term Int -- Term Int )
  over tvar? if
    rename-var
  else
    over tcompound? if
      # Compound - get functor first, then rename args
      # Stack: term counter
      over tcompound-functor    # Stack: term counter functor
      2 pick tcompound-args     # Stack: term counter functor args
      2 pick                    # Stack: term counter functor args counter (depth: 0=args,1=functor,2=counter,3=term)
      rename-termlist           # Stack: term counter functor renamed-args counter2
      # Create new compound: need functor renamed-args no-span
      2 pick                    # Stack: ... functor renamed-args counter2 functor
      2 pick                    # Stack: ... functor renamed-args counter2 functor renamed-args
      no-span tcompound-at      # Stack: term counter functor renamed-args counter2 new-compound
      # Clean up: keep new-compound and counter2
      5 roll drop               # drop term
      4 roll drop               # drop counter
      rot drop                  # drop functor
      rot drop                  # drop renamed-args
      swap                      # Stack: new-compound counter2
    else
      over tlist? if
        # List - rename head and tail
        over tlist-head over rename-term
        # Stack: term counter head2 counter2
        3 pick tlist-tail       # Stack: term counter head2 counter2 tail
        over                    # Stack: term counter head2 counter2 tail counter2
        rename-term             # Stack: term counter head2 counter2 tail2 counter3
        # Create new list: need head2 tail2 no-span
        3 pick                  # Stack: ... counter2 tail2 counter3 head2
        2 pick                  # Stack: ... counter2 tail2 counter3 head2 tail2
        no-span tlist-at        # Stack: term counter head2 counter2 tail2 counter3 new-list
        # Clean up: keep new-list and counter3
        6 roll drop             # drop term
        5 roll drop             # drop counter
        4 roll drop             # drop head2
        rot drop                # drop counter2
        rot drop                # drop tail2
        swap                    # Stack: new-list counter3
      else
        # Atom/int/float unchanged
      then
    then
  then
;

: rename-termlist ( TermList Int -- TermList Int )
  over tlnil? if
  else
    over tlcar over rename-term
    # Stack: list counter car2 counter2
    3 pick tlcdr                # Stack: list counter car2 counter2 cdr
    over                        # Stack: list counter car2 counter2 cdr counter2
    rename-termlist             # Stack: list counter car2 counter2 cdr2 counter3
    # Create new cons: need car2 cdr2
    3 pick                      # Stack: ... counter2 cdr2 counter3 car2
    2 pick                      # Stack: ... counter2 cdr2 counter3 car2 cdr2
    tlcons                      # Stack: list counter car2 counter2 cdr2 counter3 new-list
    # Clean up: keep new-list and counter3
    6 roll drop                 # drop list
    5 roll drop                 # drop counter
    4 roll drop                 # drop car2
    rot drop                    # drop counter2
    rot drop                    # drop cdr2
    swap                        # Stack: new-list counter3
  then
;

: rename-clause ( Clause Int -- Clause Int )
  over clause-head over rename-term
  # Stack: clause counter head2 counter2
  3 pick clause-body            # Stack: clause counter head2 counter2 body
  over                          # Stack: clause counter head2 counter2 body counter2
  rename-goals                  # Stack: clause counter head2 counter2 body2 counter3
  # Create new clause: need head2 body2
  3 pick                        # Stack: ... counter2 body2 counter3 head2
  2 pick                        # Stack: ... counter2 body2 counter3 head2 body2
  make-clause                   # Stack: clause counter head2 counter2 body2 counter3 new-clause
  # Clean up: keep new-clause and counter3
  6 roll drop                   # drop clause
  5 roll drop                   # drop counter
  4 roll drop                   # drop head2
  rot drop                      # drop counter2
  rot drop                      # drop body2
  swap                          # Stack: new-clause counter3
;

: rename-goals ( GoalList Int -- GoalList Int )
  over gnull? if
  else
    over gcar over rename-term
    # Stack: goals counter goal2 counter2
    3 pick gcdr                 # Stack: goals counter goal2 counter2 rest
    over                        # Stack: goals counter goal2 counter2 rest counter2
    rename-goals                # Stack: goals counter goal2 counter2 rest2 counter3
    # Create new gcons: need goal2 rest2
    3 pick                      # Stack: ... counter2 rest2 counter3 goal2
    2 pick                      # Stack: ... counter2 rest2 counter3 goal2 rest2
    gcons                       # Stack: goals counter goal2 counter2 rest2 counter3 new-goals
    # Clean up: keep new-goals and counter3
    6 roll drop                 # drop goals
    5 roll drop                 # drop counter
    4 roll drop                 # drop goal2
    rot drop                    # drop counter2
    rot drop                    # drop rest2
    swap                        # Stack: new-goals counter3
  then
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# Simple Solver (first solution only)
# ============================================

# Simple solve that returns first solution only
: solve-first ( GoalList ClauseDB Subst Int -- SolveResult )
  solve-goals-simple
;

: solve-goals-simple ( GoalList ClauseDB Subst Int -- SolveResult )
  # Stack: goals db subst counter
  # Indices: 0=counter 1=subst 2=db 3=goals
  3 pick gnull? if
    # No goals - success with current subst
    # Stack: goals db subst counter
    rot drop rot drop  # drop goals, db
    cpnil swap make-solve-success
  else
    # Get first goal and remaining goals
    3 pick gcar     # goal (depth 3 is goals)
    4 pick gcdr     # rest (now goals is at depth 4 after pushing goal)
    # Stack: goals db subst counter goal rest

    # Check if goal is a built-in
    over builtin? if
      solve-builtin-goal
    else
      # Find matching clauses in database
      # Stack: goals db subst counter goal rest
      # Indices: 0=rest 1=goal 2=counter 3=subst 4=db 5=goals
      # After over: 0=goal 1=rest 2=goal 3=counter 4=subst 5=db 6=goals
      over 5 pick matching-clauses
      # Stack: goals db subst counter goal rest matches
      try-clauses-simple
    then
  then
;

# Handle built-in goal
# Stack: goals db subst counter goal rest
: solve-builtin-goal ( GoalList ClauseDB Subst Int Term GoalList -- SolveResult )
  # Execute built-in with goal and current subst
  over    # goal
  4 pick  # subst
  exec-builtin
  # Stack: goals db subst counter goal rest result

  dup unify-ok? if
    unify-ok-subst
    # Stack: goals db subst counter goal rest new_subst

    # Clean up and continue with rest goals
    rot drop    # drop goal
    5 roll drop # drop old goals
    # Stack: db subst counter rest new_subst

    rot drop    # drop old subst
    # Stack: db counter rest new_subst

    rot         # Stack: db rest new_subst counter
    rot         # Stack: db new_subst counter rest
    3 roll      # Stack: new_subst counter rest db
    rot         # Stack: counter rest db new_subst
    3 roll      # Stack: rest db new_subst counter

    # Now: rest db new_subst counter - recurse
    solve-goals-simple
  else
    # Built-in failed
    drop drop drop drop drop drop drop
    make-solve-failure
  then
;

: try-clauses-simple ( GoalList ClauseDB Subst Int Term GoalList ClauseDB -- SolveResult )
  dup db-empty? if
    # No matches - failure
    drop drop drop drop drop drop drop
    make-solve-failure
  else
    # Try first clause
    dup db-first
    4 pick rename-clause
    # Stack: ... matches clause counter'

    # Unify goal with clause head
    # Stack: goals db subst counter goal rest matches clause counter'
    # Indices: 0=counter' 1=clause 2=matches 3=rest 4=goal 5=counter 6=subst 7=db 8=goals
    4 pick                 # get goal: stack += goal
    # Indices: 0=goal 1=counter' 2=clause ...
    2 pick clause-head     # get clause, extract head
    # Indices: 0=head 1=goal 2=counter' 3=clause 4=matches 5=rest 6=goal 7=counter 8=subst
    8 pick                 # get subst
    # Stack top: subst head goal -> ready for unify(goal, head, subst)
    unify
    # Stack: ... matches clause counter' unify_result

    dup unify-ok? if
      unify-ok-subst
      # Stack: ... matches clause counter' new_subst

      # New goals i.= clause_body ++ rest
      # Stack: ... matches clause counter' new_subst
      # Indices: 0=new_subst 1=counter' 2=clause 3=matches
      2 pick clause-body 5 pick gappend
      # Stack: ... matches clause counter' new_subst new_goals
      # Indices: 0=new_goals 1=new_subst 2=counter' 3=clause 4=matches
      #          5=rest 6=goal 7=counter 8=subst 9=db 10=goals

      # Recurse - need to set up: new_goals db new_subst counter'
      # Currently top 3 are: counter'(2) new_subst(1) new_goals(0)
      rot rot  # Reorder: new_goals(0) counter'(1) new_subst(2) -> becomes new_goals counter' new_subst
      9 pick   # Get db: new_goals counter' new_subst db
      swap     # new_goals counter' db new_subst
      rot      # new_goals db new_subst counter'
      # Stack: ... matches clause new_goals db new_subst counter'

      solve-goals-simple
      # Stack: ... matches clause result

      dup solve-success? if
        # Found solution, clean up and return
        nip nip
        6 roll drop 5 roll drop 4 roll drop
        3 roll drop rot drop swap drop
      else
        dup solve-failure? if
          # Try next clause
          drop drop  # result, clause
          db-rest
          try-clauses-simple
        else
          # Error - propagate
          nip nip
          6 roll drop 5 roll drop 4 roll drop
          3 roll drop rot drop swap drop
        then
      then
    else
      drop drop drop  # unify_fail, counter', clause
      db-rest try-clauses-simple
    then
  then
;

# ============================================
# Query Execution (simple version)
# ============================================

: run-query ( GoalList ClauseDB -- SolveResult )
  subst-empty 0 solve-first
;
