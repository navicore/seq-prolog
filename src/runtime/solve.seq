# CPS-Based Solve Engine for SeqProlog
#
# Uses continuation-passing style for clean backtracking.
# Closures capture state automatically - no manual stack management.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.
# See: https://github.com/navicore/seq-prolog/issues/5

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# Simple Recursive Solver (First Solution)
# ============================================
#
# This implements a straightforward first-solution finder.
# For full CPS with backtracking, we can extend this later.

# Entry point for queries
: run-query ( GoalList ClauseDB -- SolveResult )
  swap               # Stack: db goals
  subst-empty        # Stack: db goals subst
  rot                # Stack: goals subst db
  1000               # Stack: goals subst db counter
  solve-first
;

# Find first solution
: solve-first ( GoalList Subst ClauseDB Int -- SolveResult )
  # Stack: goals subst db counter
  # Indices: 3=goals 2=subst 1=db 0=counter

  3 pick gnull? if
    # No goals - success!
    drop drop nip    # drop counter, db, goals; keep subst
    cpnil 0 make-solve-success
  else
    # Have goals - get first goal
    3 pick gcar      # Stack: goals subst db counter goal

    dup builtin? if
      # Handle builtin
      3 pick         # get subst (index 3 because goal is on top)
      exec-builtin   # Stack: goals subst db counter result
      dup unify-ok? if
        unify-ok-subst   # Stack: goals subst db counter new-subst
        # Continue with rest of goals
        4 pick gcdr      # Stack: goals subst db counter new-subst rest-goals
        4 roll drop      # drop old subst; Stack: goals db counter new-subst rest-goals
        4 roll drop      # drop old goals; Stack: db counter new-subst rest-goals
        # Reorder to: rest-goals new-subst db counter
        swap             # Stack: db counter rest-goals new-subst
        3 roll           # Stack: counter rest-goals new-subst db
        3 roll           # Stack: rest-goals new-subst db counter
        solve-first
      else
        # Builtin failed
        drop drop drop drop drop make-solve-failure
      then
    else
      # User predicate - find matching clauses
      # Stack: goals subst db counter goal (5 items)
      # Indices: 4=goals, 3=subst, 2=db, 1=counter, 0=goal
      2 pick           # get db (at index 2)
      # Stack: goals subst db counter goal db (6 items)
      matching-clauses # (Term ClauseDB -- ClauseDB) consumes goal and db
      # Stack: goals subst db counter matching (5 items)
      # Now need to call try-first-match ( GoalList Subst ClauseDB Int ClauseDB -- SolveResult )
      # which is exactly what we have: goals subst db counter matching
      try-first-match
    then
  then
;

# Try matching clauses until one succeeds
: try-first-match ( GoalList Subst ClauseDB Int ClauseDB -- SolveResult )
  # Stack: goals subst db counter matching (5 items)
  dup db-empty? if
    # No matching clauses - fail
    drop drop drop drop drop make-solve-failure
  else
    # Get first clause and rename
    dup db-first     # Stack: goals subst db counter matching clause (6 items)
    2 pick           # get counter (index 2 with clause on top: 5=goals 4=subst 3=db 2=counter 1=matching 0=clause)
    rename-clause    # (Clause Int -- Clause Int)
    # Stack: goals subst db counter matching renamed new-counter (7 items)

    # Try to unify goal with clause head
    over clause-head  # get head from renamed
    # Stack: goals subst db counter matching renamed new-counter head (8 items)
    7 pick gcar       # get first goal from goals (index 7)
    # Stack: goals subst db counter matching renamed new-counter head goal (9 items)
    7 pick            # get subst (index 7: 8=goals 7=subst ...)
    # Stack: goals subst db counter matching renamed new-counter head goal subst (10 items)
    unify
    # Stack: goals subst db counter matching renamed new-counter result (8 items)

    dup unify-ok? if
      # Unification succeeded
      unify-ok-subst
      # Stack: goals subst db counter matching renamed new-counter new-subst (8 items)

      # Get body and rest-goals for combined
      2 pick clause-body  # renamed at index 2
      # Stack: goals subst db counter matching renamed new-counter new-subst body (9 items)
      8 pick gcdr         # goals at index 8
      # Stack: goals subst db counter matching renamed new-counter new-subst body rest (10 items)
      gappend
      # Stack: goals subst db counter matching renamed new-counter new-subst combined (9 items)

      # Extract what we need: combined(0), new-subst(1), db(6), new-counter(2)
      # Then call solve-first with: combined new-subst db new-counter
      # Use helper to cleanly extract and reorder
      try-first-match-continue
    else
      # Unification failed - try next clause
      drop             # result
      drop             # new-counter
      drop             # renamed
      db-rest          # rest of matching
      try-first-match
    then
  then
;

# Helper to extract values and call solve-first
# Stack in: goals subst db counter matching renamed new-counter new-subst combined (9 items)
# Stack out: (calls solve-first with combined new-subst db new-counter)
: try-first-match-continue ( GoalList Subst ClauseDB Int ClauseDB Clause Int Subst GoalList -- SolveResult )
  # Indices: 8=goals 7=subst 6=db 5=counter 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined
  # Need for solve-first: combined new-subst db new-counter

  # Strategy: copy what we need to top, then drop the rest
  dup              # combined -> index 0
  2 pick           # new-subst (was at 1, now at 2 after dup)
  8 pick           # db (was at 6, now at 8 after 2 additions)
  5 pick           # new-counter (was at 2, now at 5 after 3 additions)
  # Stack (13 items): goals subst db counter matching renamed new-counter new-subst combined combined' new-subst' db' new-counter'
  # Indices: 12=goals 11=subst 10=db 9=counter 8=matching 7=renamed 6=new-counter 5=new-subst 4=combined 3=combined' 2=new-subst' 1=db' 0=new-counter'

  # Drop original 9 items (indices 4-12)
  # Each roll+drop reduces stack by 1
  12 roll drop     # goals (after: 12 items, indices 0-11)
  11 roll drop     # subst (after: 11 items)
  10 roll drop     # db-old (after: 10 items)
  9 roll drop      # counter (after: 9 items)
  8 roll drop      # matching (after: 8 items)
  7 roll drop      # renamed (after: 7 items)
  6 roll drop      # new-counter-old (after: 6 items)
  5 roll drop      # new-subst-old (after: 5 items)
  4 roll drop      # combined-old (after: 4 items)
  # Stack: combined' new-subst' db' new-counter' (4 items)
  # But solve-first expects: goals subst db counter
  # We have: combined new-subst db new-counter - that's correct!

  solve-first
;

# Multi-solution query - for now just returns first
: run-query-all ( GoalList ClauseDB -- SolveResult )
  run-query
;
