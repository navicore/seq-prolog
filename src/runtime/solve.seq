# CPS-Based Solve Engine for SeqProlog
#
# Uses continuation-passing style for clean backtracking.
# Closures capture state automatically - no manual stack management.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.
# See: https://github.com/navicore/seq-prolog/issues/5

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# Query Interface
# ============================================
#
# TODO: Implement full CPS solver with closures for backtracking
# For now, using simple recursive solver (run-query-first)

# Run a query, print first solution
: run-query ( GoalList ClauseDB -- SolveResult )
  # For now, use a simple wrapper that captures result
  subst-empty swap  # goals subst db
  rot               # subst db goals
  rot               # db goals subst
  rot               # goals subst db
  1000              # counter (offset to avoid query var collision)
  run-query-first
;

# Simple first-solution finder (non-CPS for now, will convert)
: run-query-first ( GoalList Subst ClauseDB Int -- SolveResult )
  # Stack: goals subst db counter
  # Positions: 3=goals 2=subst 1=db 0=counter
  3 pick gnull? if
    # No goals - success
    # Need: subst cpnil counter for make-solve-success (Subst ChoiceStack Int)
    3 roll drop  # drop goals: (subst db counter)
    swap drop    # drop db: (subst counter)
    swap cpnil rot  # (subst cpnil counter)
    make-solve-success
  else
    # Get first goal
    3 pick gcar
    dup builtin? if
      # Handle builtin
      # Stack: goals subst db counter goal
      # Positions: 4=goals 3=subst 2=db 1=counter 0=goal
      3 pick exec-builtin  # exec-builtin (Term Subst -- UnifyResult): goal at 1, subst at 0
      # Stack: goals subst db counter UnifyResult
      dup unify-ok? if
        unify-ok-subst
        # Stack: goals subst db counter new-subst
        # Positions: 4=goals 3=subst 2=db 1=counter 0=new-subst
        # Build new args: rest-goals new-subst db counter
        4 pick gcdr swap 3 pick 3 pick
        # Stack: goals subst db counter rest-goals new-subst db counter
        # Positions: 7=goals 6=subst 5=db 4=counter 3=rest-goals 2=new-subst 1=db 0=counter
        4 roll drop 4 roll drop 4 roll drop 4 roll drop
        run-query-first
      else
        drop drop drop drop drop
        make-solve-failure
      then
    else
      # Find matching clauses
      dup 3 pick matching-clauses
      dup db-empty? if
        drop drop drop drop drop drop
        make-solve-failure
      else
        # Try first clause
        dup db-first 3 pick rename-clause
        # Stack: goals subst db counter goal matches clause' counter'
        # Positions: 7=goals 6=subst 5=db 4=counter 3=goal 2=matches 1=clause' 0=counter'
        # Note: rename-clause returns (Clause Int) with counter' on top
        over clause-head 4 pick 8 pick unify
        # over clause-head: gets head from clause' (at pos 1)
        # 4 pick: gets goal (at pos 4 after adding head)
        # 8 pick: gets subst (at pos 8 after adding goal)
        # Stack after unify: goals subst db counter goal matches clause' counter' UnifyResult
        dup unify-ok? if
          unify-ok-subst
          # Stack: goals subst db counter goal matches clause' counter' new-subst
          # Positions: 8=goals 7=subst 6=db 5=counter 4=goal 3=matches 2=clause' 1=counter' 0=new-subst

          # Get clause body and append to rest of goals
          2 pick clause-body  # get body from clause' (at pos 2)
          9 pick gcdr         # get rest of goals (goals at pos 9 after adding body)
          gappend             # new-goals = body ++ rest
          # Stack: goals subst db counter goal matches clause' counter' new-subst new-goals
          # Positions: 9=goals 8=subst 7=db 6=counter 5=goal 4=matches 3=clause' 2=counter' 1=new-subst 0=new-goals

          # Build args for recursive call: new-goals new-subst db counter'
          swap        # swap new-goals and new-subst
          7 pick      # get db (at pos 7)
          3 pick      # get counter' (at pos 3)
          # Stack: goals subst db counter goal matches clause' counter' new-goals new-subst db counter'
          # Positions: 11=goals 10=subst 9=db 8=counter 7=goal 6=matches 5=clause' 4=counter' 3=new-goals 2=new-subst 1=db 0=counter'

          run-query-first
          # run-query-first consumes 4 items (new-goals new-subst db counter') and produces 1 (result)
          # Stack: goals subst db counter goal matches clause' counter' result
          # Positions: 8=goals 7=subst 6=db 5=counter 4=goal 3=matches 2=clause' 1=counter' 0=result
          # Check if recursion succeeded
          dup solve-success? if
            # Success - drop all the old state and return
            # Drop 8 items (positions 1-8), keeping result
            swap drop  # drop counter'
            swap drop  # drop clause'
            swap drop  # drop matches
            swap drop  # drop goal
            swap drop  # drop counter
            swap drop  # drop db
            swap drop  # drop subst
            swap drop  # drop goals
            # Stack: result
          else
            # Recursion failed - try next clause
            drop  # drop failed result
            # Stack: goals subst db counter goal matches clause' counter'
            drop  # drop counter'
            drop  # drop clause'
            # Stack: goals subst db counter goal matches
            db-rest  # get remaining matches
            run-query-first-try-clauses
          then
        else
          # Try next clause - unification failed
          # Stack: goals subst db counter goal matches clause counter' UnifyResult
          drop drop drop  # drop UnifyResult, counter', clause
          # Stack: goals subst db counter goal matches
          db-rest         # get remaining matches
          # Stack: goals subst db counter goal rest-matches
          run-query-first-try-clauses
        then
      then
    then
  then
;

# Helper to try remaining clauses
: run-query-first-try-clauses ( GoalList Subst ClauseDB Int Term ClauseDB -- SolveResult )
  # Input stack: goals subst db counter goal matches
  # Positions: 5=goals 4=subst 3=db 2=counter 1=goal 0=matches
  dup db-empty? if
    drop drop drop drop drop drop
    make-solve-failure
  else
    dup db-first 3 pick rename-clause
    # Stack: goals subst db counter goal matches clause' counter'
    # Positions: 7=goals 6=subst 5=db 4=counter 3=goal 2=matches 1=clause' 0=counter'
    over clause-head 4 pick 8 pick unify
    dup unify-ok? if
      unify-ok-subst
      # Stack: goals subst db counter goal matches clause' counter' new-subst
      # Positions: 8=goals 7=subst 6=db 5=counter 4=goal 3=matches 2=clause' 1=counter' 0=new-subst

      # Get clause body and append to rest of goals
      2 pick clause-body  # get body from clause'
      9 pick gcdr         # get rest of goals
      gappend             # new-goals = body ++ rest
      # Stack: goals subst db counter goal matches clause' counter' new-subst new-goals
      # Positions: 9=goals 8=subst 7=db 6=counter 5=goal 4=matches 3=clause' 2=counter' 1=new-subst 0=new-goals

      # Build args for recursive call: new-goals new-subst db counter'
      swap 7 pick 3 pick
      # Stack: goals subst db counter goal matches clause' counter' new-goals new-subst db counter'

      run-query-first
      # run-query-first consumes 4 items and produces 1 (result)
      # Stack: goals subst db counter goal matches clause' counter' result
      # Positions: 8=goals 7=subst 6=db 5=counter 4=goal 3=matches 2=clause' 1=counter' 0=result
      dup solve-success? if
        # Success - drop all the old state and return
        swap drop  # drop counter'
        swap drop  # drop clause'
        swap drop  # drop matches
        swap drop  # drop goal
        swap drop  # drop counter
        swap drop  # drop db
        swap drop  # drop subst
        swap drop  # drop goals
        # Stack: result
      else
        # Recursion failed - try next clause
        drop  # drop failed result
        # Stack: goals subst db counter goal matches clause' counter'
        drop  # drop counter'
        drop  # drop clause'
        # Stack: goals subst db counter goal matches
        db-rest  # get remaining matches
        run-query-first-try-clauses
      then
    else
      # Unification failed - try next clause
      # Stack: goals subst db counter goal matches clause' counter' UnifyResult
      drop drop drop  # drop UnifyResult, counter', clause'
      db-rest         # get remaining matches
      # Stack: goals subst db counter goal rest-matches
      run-query-first-try-clauses
    then
  then
;

# Placeholder for multi-solution query (TODO: implement with full CPS)
: run-query-all ( GoalList ClauseDB -- SolveResult )
  run-query  # For now, same as run-query
;
