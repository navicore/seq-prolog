# Solve Engine for SeqProlog
#
# Simple depth-first solver that returns first solution.
# TODO: Add weave-based backtracking for multiple solutions.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Renaming (Simple counter-based)
# ============================================
# KNOWN LIMITATION: Uses simple counter-based renaming.
# Same-named variables in clause head and body get different IDs.
# This works for simple cases but breaks proper Prolog semantics.
# Example: In `foo(X) :- bar(X)`, head X and body X should share IDs.
# See: https://github.com/navicore/seq-prolog/issues/5

: rename-var ( Term Int -- Term Int )
  # Input: var counter
  # Output: new-var counter+1
  # Stack: var counter
  dup                    # var counter counter
  1 i.+                  # var counter counter+1
  rot                    # counter counter+1 var
  tvar-name              # counter counter+1 "name"
  rot                    # counter+1 "name" counter
  no-span tvar-at        # counter+1 new-var
  swap                   # new-var counter+1
;

: rename-term ( Term Int -- Term Int )
  over tvar? if
    rename-var
  else
    over tcompound? if
      # Compound - get functor first, then rename args
      # Stack: term counter
      over tcompound-functor    # Stack: term counter functor
      2 pick tcompound-args     # Stack: term counter functor args
      2 pick                    # Stack: term counter functor args counter (depth: 0=args,1=functor,2=counter,3=term)
      rename-termlist           # Stack: term counter functor renamed-args counter2
      # Create new compound: need functor renamed-args no-span
      2 pick                    # Stack: ... functor renamed-args counter2 functor
      2 pick                    # Stack: ... functor renamed-args counter2 functor renamed-args
      no-span tcompound-at      # Stack: term counter functor renamed-args counter2 new-compound
      # Clean up: keep new-compound and counter2
      5 roll drop               # drop term
      4 roll drop               # drop counter
      rot drop                  # drop functor
      rot drop                  # drop renamed-args
      swap                      # Stack: new-compound counter2
    else
      over tlist? if
        # List - rename head and tail
        over tlist-head over rename-term
        # Stack: term counter head2 counter2
        3 pick tlist-tail       # Stack: term counter head2 counter2 tail
        over                    # Stack: term counter head2 counter2 tail counter2
        rename-term             # Stack: term counter head2 counter2 tail2 counter3
        # Create new list: need head2 tail2 no-span
        3 pick                  # Stack: ... counter2 tail2 counter3 head2
        2 pick                  # Stack: ... counter2 tail2 counter3 head2 tail2
        no-span tlist-at        # Stack: term counter head2 counter2 tail2 counter3 new-list
        # Clean up: keep new-list and counter3
        6 roll drop             # drop term
        5 roll drop             # drop counter
        4 roll drop             # drop head2
        rot drop                # drop counter2
        rot drop                # drop tail2
        swap                    # Stack: new-list counter3
      else
        # Atom/int/float unchanged
      then
    then
  then
;

: rename-termlist ( TermList Int -- TermList Int )
  over tlnil? if
  else
    over tlcar over rename-term
    # Stack: list counter car2 counter2
    3 pick tlcdr                # Stack: list counter car2 counter2 cdr
    over                        # Stack: list counter car2 counter2 cdr counter2
    rename-termlist             # Stack: list counter car2 counter2 cdr2 counter3
    # Create new cons: need car2 cdr2
    3 pick                      # Stack: ... counter2 cdr2 counter3 car2
    2 pick                      # Stack: ... counter2 cdr2 counter3 car2 cdr2
    tlcons                      # Stack: list counter car2 counter2 cdr2 counter3 new-list
    # Clean up: keep new-list and counter3
    6 roll drop                 # drop list
    5 roll drop                 # drop counter
    4 roll drop                 # drop car2
    rot drop                    # drop counter2
    rot drop                    # drop cdr2
    swap                        # Stack: new-list counter3
  then
;

: rename-clause ( Clause Int -- Clause Int )
  over clause-head over rename-term
  # Stack: clause counter head2 counter2
  3 pick clause-body            # Stack: clause counter head2 counter2 body
  over                          # Stack: clause counter head2 counter2 body counter2
  rename-goals                  # Stack: clause counter head2 counter2 body2 counter3
  # Create new clause: need head2 body2
  3 pick                        # Stack: ... counter2 body2 counter3 head2
  2 pick                        # Stack: ... counter2 body2 counter3 head2 body2
  make-clause                   # Stack: clause counter head2 counter2 body2 counter3 new-clause
  # Clean up: keep new-clause and counter3
  6 roll drop                   # drop clause
  5 roll drop                   # drop counter
  4 roll drop                   # drop head2
  rot drop                      # drop counter2
  rot drop                      # drop body2
  swap                          # Stack: new-clause counter3
;

: rename-goals ( GoalList Int -- GoalList Int )
  over gnull? if
  else
    over gcar over rename-term
    # Stack: goals counter goal2 counter2
    3 pick gcdr                 # Stack: goals counter goal2 counter2 rest
    over                        # Stack: goals counter goal2 counter2 rest counter2
    rename-goals                # Stack: goals counter goal2 counter2 rest2 counter3
    # Create new gcons: need goal2 rest2
    3 pick                      # Stack: ... counter2 rest2 counter3 goal2
    2 pick                      # Stack: ... counter2 rest2 counter3 goal2 rest2
    gcons                       # Stack: goals counter goal2 counter2 rest2 counter3 new-goals
    # Clean up: keep new-goals and counter3
    6 roll drop                 # drop goals
    5 roll drop                 # drop counter
    4 roll drop                 # drop goal2
    rot drop                    # drop counter2
    rot drop                    # drop rest2
    swap                        # Stack: new-goals counter3
  then
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# Simple Solver (first solution only)
# ============================================

# Simple solve that returns first solution only
: solve-first ( GoalList ClauseDB Subst Int -- SolveResult )
  solve-goals-simple
;

: solve-goals-simple ( GoalList ClauseDB Subst Int -- SolveResult )
  # Stack: goals db subst counter
  # Indices: 0=counter 1=subst 2=db 3=goals
  3 pick gnull? if
    # No goals - success with current subst
    # Stack: goals db subst counter
    rot drop rot drop  # drop goals, db
    cpnil swap make-solve-success
  else
    # Get first goal and remaining goals
    3 pick gcar     # goal (depth 3 is goals)
    4 pick gcdr     # rest (now goals is at depth 4 after pushing goal)
    # Stack: goals db subst counter goal rest

    # Check if goal is a built-in
    over builtin? if
      solve-builtin-goal
    else
      # Find matching clauses in database
      # Stack: goals db subst counter goal rest
      # Indices: 0=rest 1=goal 2=counter 3=subst 4=db 5=goals
      # After over: 0=goal 1=rest 2=goal 3=counter 4=subst 5=db 6=goals
      over 5 pick matching-clauses
      # Stack: goals db subst counter goal rest matches
      try-clauses-simple
    then
  then
;

# Handle built-in goal
# Stack: goals db subst counter goal rest
: solve-builtin-goal ( GoalList ClauseDB Subst Int Term GoalList -- SolveResult )
  # Execute built-in with goal and current subst
  over    # goal
  4 pick  # subst
  exec-builtin
  # Stack: goals db subst counter goal rest result

  dup unify-ok? if
    unify-ok-subst
    # Stack: goals db subst counter goal rest new_subst

    # Clean up and continue with rest goals
    rot drop    # drop goal
    5 roll drop # drop old goals
    # Stack: db subst counter rest new_subst

    rot drop    # drop old subst
    # Stack: db counter rest new_subst

    rot         # Stack: db rest new_subst counter
    rot         # Stack: db new_subst counter rest
    3 roll      # Stack: new_subst counter rest db
    rot         # Stack: counter rest db new_subst
    3 roll      # Stack: rest db new_subst counter

    # Now: rest db new_subst counter - recurse
    solve-goals-simple
  else
    # Built-in failed
    drop drop drop drop drop drop drop
    make-solve-failure
  then
;

: try-clauses-simple ( GoalList ClauseDB Subst Int Term GoalList ClauseDB -- SolveResult )
  dup db-empty? if
    # No matches - failure
    drop drop drop drop drop drop drop
    make-solve-failure
  else
    # Try first clause
    dup db-first
    4 pick rename-clause
    # Stack: ... matches clause counter'

    # Unify goal with clause head
    # Stack: goals db subst counter goal rest matches clause counter'
    # Indices: 0=counter' 1=clause 2=matches 3=rest 4=goal 5=counter 6=subst 7=db 8=goals
    4 pick                 # get goal: stack += goal
    # Indices: 0=goal 1=counter' 2=clause ...
    2 pick clause-head     # get clause, extract head
    # Indices: 0=head 1=goal 2=counter' 3=clause 4=matches 5=rest 6=goal 7=counter 8=subst
    8 pick                 # get subst
    # Stack top: subst head goal -> ready for unify(goal, head, subst)
    unify
    # Stack: ... matches clause counter' unify_result

    dup unify-ok? if
      unify-ok-subst
      # Stack: ... matches clause counter' new_subst

      # New goals i.= clause_body ++ rest
      # Stack: ... matches clause counter' new_subst
      # Indices: 0=new_subst 1=counter' 2=clause 3=matches
      2 pick clause-body 5 pick gappend
      # Stack: ... matches clause counter' new_subst new_goals
      # Indices: 0=new_goals 1=new_subst 2=counter' 3=clause 4=matches
      #          5=rest 6=goal 7=counter 8=subst 9=db 10=goals

      # Recurse - need to set up: new_goals db new_subst counter'
      # Currently top 3 are: counter'(2) new_subst(1) new_goals(0)
      rot rot  # Reorder: new_goals(0) counter'(1) new_subst(2) -> becomes new_goals counter' new_subst
      9 pick   # Get db: new_goals counter' new_subst db
      swap     # new_goals counter' db new_subst
      rot      # new_goals db new_subst counter'
      # Stack: ... matches clause new_goals db new_subst counter'

      solve-goals-simple
      # Stack: ... matches clause result

      dup solve-success? if
        # Found solution, clean up and return
        nip nip
        6 roll drop 5 roll drop 4 roll drop
        3 roll drop rot drop swap drop
      else
        dup solve-failure? if
          # Try next clause
          drop drop  # result, clause
          db-rest
          try-clauses-simple
        else
          # Error - propagate
          nip nip
          6 roll drop 5 roll drop 4 roll drop
          3 roll drop rot drop swap drop
        then
      then
    else
      drop drop drop  # unify_fail, counter', clause
      db-rest try-clauses-simple
    then
  then
;

# ============================================
# Multi-Solution Solver (with choice points)
# ============================================

# Solve with choice point tracking
: solve-all ( GoalList ClauseDB Subst Int -- SolveResult )
  solve-goals-with-cp
;

: solve-goals-with-cp ( GoalList ClauseDB Subst Int -- SolveResult )
  # Stack: goals db subst counter
  3 pick gnull? if
    # No goals - success with empty choice stack
    # Stack: goals db subst counter
    # Need: subst cpnil counter for make-solve-success
    rot drop rot drop cpnil swap make-solve-success
  else
    # Get first goal and remaining goals
    3 pick gcar     # goal
    4 pick gcdr     # rest
    # Stack: goals db subst counter goal rest

    # Check if goal is a built-in
    over builtin? if
      # Handle builtin (no choice points for builtins)
      solve-builtin-goal
    else
      # Find matching clauses
      over 5 pick matching-clauses
      # Stack: goals db subst counter goal rest matches
      try-clauses-with-cp
    then
  then
;

# Try clauses with choice point creation
: try-clauses-with-cp ( GoalList ClauseDB Subst Int Term GoalList ClauseDB -- SolveResult )
  # Stack: goals db subst counter goal rest matches
  # Indices: 0=matches 1=rest 2=goal 3=counter 4=subst 5=db 6=goals
  dup db-empty? if
    # No matches - failure
    drop drop drop drop drop drop drop
    make-solve-failure
  else
    # Save state for potential choice point
    # We need: goals(=goal::rest), remaining_matches(=db-rest), orig_db, subst, counter

    # Try first clause
    dup db-first
    4 pick rename-clause
    # Stack: goals db subst counter goal rest matches clause counter'

    # Unify goal with clause head
    4 pick                 # get goal
    2 pick clause-head     # get head
    8 pick                 # get subst
    unify
    # Stack: goals db subst counter goal rest matches clause counter' unify_result

    dup unify-ok? if
      unify-ok-subst
      # Stack: goals db subst counter goal rest matches clause counter' new_subst

      # New goals = clause_body ++ rest
      2 pick clause-body 5 pick gappend
      # Stack: ... matches clause counter' new_subst new_goals

      # Recurse with new goals
      rot rot        # new_goals counter' new_subst
      9 pick         # get db
      swap           # new_goals counter' db new_subst
      rot            # new_goals db new_subst counter'

      solve-goals-with-cp
      # Stack: goals db subst counter goal rest matches clause result

      dup solve-success? if
        # Success! Check if there are remaining clauses for choice point
        # Stack: goals db subst counter goal rest matches clause result

        # Check if matches has more clauses
        # Stack indices: 0=result 1=clause 2=matches 3=rest ...
        2 pick db-rest db-empty? if
          # No more clauses - just return result as-is
          nip nip
          6 roll drop 5 roll drop 4 roll drop
          3 roll drop rot drop swap drop
        else
          # More clauses - create choice point and add to result
          # For simplicity, use a helper approach:
          # 1. Save the result's fields
          # 2. Build choice point from saved state
          # 3. Build new result with updated cp_stack

          # Stack: goals db subst counter goal rest matches clause result
          # Save result fields to locals-like arrangement
          dup solve-success-subst    # result res_subst
          over solve-success-cp-stack # result res_subst res_cp
          2 pick solve-success-var-counter # result res_subst res_cp res_ctr
          # Drop original result
          3 roll drop                 # res_subst res_cp res_ctr
          # Stack now: goals db subst counter goal rest matches clause res_subst res_cp res_ctr

          # Build choice point: need (GoalList, matches_rest, orig_db, old_subst, old_counter)
          # Stack indices: 0=res_ctr 1=res_cp 2=res_subst 3=clause 4=matches 5=rest 6=goal 7=counter 8=subst 9=db 10=goals

          # goal::rest
          6 pick 6 pick gcons         # cp_goals
          # Now: ... res_ctr cp_goals (indices shifted by 1)

          # remaining matches
          5 pick db-rest              # remaining (matches is now at index 5)
          # Now: ... res_ctr cp_goals remaining

          # orig_db
          11 pick                     # orig_db (db is at index 11)
          # Now: ... cp_goals remaining orig_db

          # old_subst
          11 pick                     # old_subst (subst is at index 11)

          # old_counter
          11 pick                     # old_counter (counter is at index 11)
          # Now top 5: cp_goals remaining orig_db old_subst old_counter

          make-cp                     # creates choice point
          # Stack: goals db subst counter goal rest matches clause res_subst res_cp res_ctr cp

          # Add to result cp_stack
          # indices: 0=cp 1=res_ctr 2=res_cp 3=res_subst ...
          2 pick cpcons               # new_cp = cpcons(cp, res_cp)
          # Stack: ... res_ctr cp new_cp

          # Build result: (res_subst, new_cp, res_ctr)
          # After cpcons: indices 0=new_cp 1=res_ctr 2=res_cp 3=res_subst 4=clause ...
          3 pick                      # res_subst
          # Stack: ... res_ctr cp new_cp res_subst

          swap                        # ... res_subst new_cp (new_cp on top)
          # indices: 0=new_cp 1=res_subst 2=res_ctr 3=res_cp ...
          2 pick                      # ... res_subst new_cp res_ctr
          make-solve-success          # new_result
          # Stack: ... res_ctr cp new_result

          # Cleanup: need to drop all the intermediate values
          # Stack: goals db subst counter goal rest matches clause res_subst res_cp res_ctr cp new_result
          # 13 items total

          nip nip nip nip nip         # drop cp res_ctr res_cp res_subst clause
          # Stack: goals db subst counter goal rest matches new_result
          6 roll drop 5 roll drop 4 roll drop
          3 roll drop rot drop swap drop
        then
      else
        dup solve-failure? if
          # Try next clause
          drop drop  # result, clause
          db-rest
          try-clauses-with-cp
        else
          # Error - propagate
          nip nip
          6 roll drop 5 roll drop 4 roll drop
          3 roll drop rot drop swap drop
        then
      then
    else
      # Unify failed - try next clause
      drop drop drop  # unify_fail, counter', clause
      db-rest try-clauses-with-cp
    then
  then
;

# Continue solving from a choice point
# Returns next solution or failure if exhausted
: solve-next ( ChoiceStack ClauseDB -- SolveResult )
  over cpnil? if
    # No more choice points - exhausted
    drop drop make-solve-failure
  else
    # Pop the choice point
    # Stack: cp_stack db
    swap                   # db cp_stack
    dup cpcar              # db cp_stack cp
    swap cpcdr             # db cp rest_cp_stack

    # Extract cp fields
    # Stack: db cp rest_cp_stack
    # indices: 0=rest_cp_stack 1=cp 2=db

    # Get goals, matches, subst, counter from cp
    over cp-goals          # db cp rest_cp goals (cp is at index 2 now)
    # indices: 0=goals 1=rest_cp 2=cp 3=db

    2 pick cp-matches      # cp is at index 2 -> db cp rest_cp goals matches
    # indices: 0=matches 1=goals 2=rest_cp 3=cp 4=db

    3 pick cp-subst        # cp at index 3 -> ... goals matches subst
    # indices: 0=subst 1=matches 2=goals 3=rest_cp 4=cp 5=db
    4 pick cp-var-counter  # cp is now at index 4
    # Stack: db cp rest_cp goals matches subst counter

    # Split goals into goal and rest_goals
    3 pick gcar            # goal (goals at index 3)
    4 pick gcdr            # rest_goals (goals at index 4)
    # Stack: db cp rest_cp goals matches subst counter goal rest_goals
    # indices: 0=rest_goals 1=goal 2=counter 3=subst 4=matches 5=goals 6=rest_cp 7=cp 8=db

    # For try-clauses-with-cp we need:
    # ( GoalList ClauseDB Subst Int Term GoalList ClauseDB -- SolveResult )
    # That's: goals db subst counter goal rest_goals matches

    # Current stack: db cp rest_cp goals matches subst counter goal rest_goals
    # indices: 0=rest_goals 1=goal 2=counter 3=subst 4=matches 5=goals 6=rest_cp 7=cp 8=db

    5 pick                 # goals (at 5)
    # 0=goals 1=rest_goals 2=goal 3=counter 4=subst 5=matches 6=goals 7=rest_cp 8=cp 9=db
    9 pick                 # db (at 9)
    # 0=db 1=goals 2=rest_goals 3=goal 4=counter 5=subst 6=matches ...
    5 pick                 # subst (at 5)
    # 0=subst 1=db 2=goals 3=rest_goals 4=goal 5=counter 6=subst ...
    5 pick                 # counter (at 5)
    # 0=counter 1=subst 2=db 3=goals 4=rest_goals 5=goal 6=counter ...
    5 pick                 # goal (at 5)
    # 0=goal 1=counter 2=subst 3=db 4=goals 5=rest_goals 6=goal ...
    5 pick                 # rest_goals (was at 0, +5 pushes = 5)
    # 0=rest_goals 1=goal 2=counter 3=subst 4=db 5=goals 6=rest_goals 7=goal ...
    10 pick                # matches (was at 4, +6 pushes = 10)
    # Stack has: (orig) + goals db subst counter goal rest_goals matches

    try-clauses-with-cp
    # Stack: db cp rest_cp goals matches subst counter goal rest_goals result

    # Clean up the intermediate values (9 items before result)
    nip nip nip nip nip nip nip nip nip
  then
;

# ============================================
# Query Execution
# ============================================

: run-query ( GoalList ClauseDB -- SolveResult )
  subst-empty 0 solve-first
;

# Run query returning all solutions via choice points
: run-query-all ( GoalList ClauseDB -- SolveResult )
  subst-empty 0 solve-all
;
