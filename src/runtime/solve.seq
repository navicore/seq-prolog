# CPS-Based Solve Engine for SeqProlog
#
# Uses continuation-passing style for clean backtracking.
# Closures capture state automatically - no manual stack management.

include "../term"
include "unify"
include "../builtins"

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.
# See: https://github.com/navicore/seq-prolog/issues/5

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Find Matching Clauses
# ============================================

: matching-clauses ( Term ClauseDB -- ClauseDB )
  db-empty matching-loop ;

: matching-loop ( Term ClauseDB ClauseDB -- ClauseDB )
  # Stack: goal input-db result-db
  over db-empty? if
    # Input exhausted, return result
    nip nip
  else
    # Check if first clause matches
    over db-first clause-head   # Stack: goal input-db result-db head
    # Indices: 0=head 1=result-db 2=input-db 3=goal
    3 pick could-match? if      # could-match? consumes head and goal-copy, returns bool
      # Match! Add clause to result
      # Stack: goal input-db result-db (head was consumed by could-match?)
      over db-first             # Stack: goal input-db result-db clause
      swap                      # Stack: goal input-db clause result-db
      db-append                 # Stack: goal input-db new-result
      swap db-rest swap         # Stack: goal input-rest new-result
      matching-loop
    else
      # No match, continue with rest
      # Stack: goal input-db result-db (head was consumed by could-match?)
      swap db-rest swap         # Stack: goal input-rest result-db
      matching-loop
    then
  then
;

: could-match? ( Term Term -- Bool )
  over tcompound? over tcompound? and if
    over tcompound-functor over tcompound-functor string.equal? if
      over tcompound-args tllen swap tcompound-args tllen i.= nip
    else
      drop drop false
    then
  else
    over tatom? over tatom? and if
      over tatom-name swap tatom-name string.equal? nip
    else
      drop drop true  # Variables can match anything
    then
  then
;

# ============================================
# CPS-Based Solver
# ============================================
#
# Continuation-passing style solver for proper backtracking.
# Closures capture state automatically - no manual stack management.
#
# Continuation types:
# SuccessCont = Closure[Subst -- SolveResult]  (called with solution)
# FailCont = Closure[-- SolveResult]           (called to backtrack)

# ============================================
# Entry Points
# ============================================

# run-query: Execute a query and return first solution
: run-query ( GoalList ClauseDB -- SolveResult )
  swap               # Stack: db goals
  subst-empty        # Stack: db goals subst
  rot                # Stack: goals subst db
  1000               # Stack: goals subst db counter

  # Create success continuation: Subst -> SolveResult
  [ cpnil 0 make-solve-success ]

  # Create failure continuation: -> SolveResult
  [ make-solve-failure ]

  # Stack: goals subst db counter succ fail
  # Reorder for solve-cps: goals subst succ fail db counter
  rot                # Stack: goals subst db succ fail counter
  3 roll             # Stack: goals subst succ fail counter db
  swap               # Stack: goals subst succ fail db counter

  solve-cps
;

# run-query-all: Alias for run-query (multi-solution via continuation calling)
: run-query-all ( GoalList ClauseDB -- SolveResult )
  run-query
;

# ============================================
# Core CPS Solver
# ============================================

# solve-cps: Main solver with continuations
# Stack: goals subst succ fail db counter
# Returns: SolveResult
: solve-cps ( GoalList Subst SuccCont FailCont ClauseDB Int -- SolveResult )
  # Check for empty goals
  5 pick gnull? if
    # No goals - SUCCESS!
    # Call success continuation with current substitution
    # Stack: goals subst succ fail db counter
    # Indices: 5=goals 4=subst 3=succ 2=fail 1=db 0=counter
    drop drop        # drop counter, db (4 items)
    # Stack: goals subst succ fail
    drop             # drop fail (3 items)
    # Stack: goals subst succ
    # Indices: 2=goals 1=subst 0=succ
    # Need: subst on stack, succ on top for call
    rot              # Stack: subst succ goals
    drop             # Stack: subst succ
    call             # succ(subst) -> SolveResult
  else
    # Have goals - solve first one
    5 pick gcar      # Stack: goals subst succ fail db counter goal

    dup builtin? if
      # Built-in predicate
      solve-builtin-cps
    else
      # User-defined predicate - find matching clauses
      # Stack: goals subst succ fail db counter goal
      2 pick           # get db
      matching-clauses # Stack: goals subst succ fail db counter matching
      try-clauses-cps
    then
  then
;

# ============================================
# Built-in Handling
# ============================================

# solve-builtin-cps: Handle built-in predicates in CPS style
# Stack: goals subst succ fail db counter goal
: solve-builtin-cps ( GoalList Subst SuccCont FailCont ClauseDB Int Term -- SolveResult )
  # Execute the builtin: goal subst -> UnifyResult
  5 pick             # get subst (idx: 6=goals 5=subst 4=succ 3=fail 2=db 1=counter 0=goal)
  exec-builtin       # Stack: goals subst succ fail db counter result (7 items)

  dup unify-ok? if
    unify-ok-subst   # Stack: goals subst succ fail db counter new-subst (7 items)
    # idx: 6=goals 5=subst 4=succ 3=fail 2=db 1=counter 0=new-subst

    # Get rest-goals and build new stack for solve-cps
    6 pick gcdr      # rest-goals; Stack now 8 items
    # idx: 7=goals 6=subst 5=succ 4=fail 3=db 2=counter 1=new-subst 0=rest-goals

    # solve-cps needs: goals subst succ fail db counter
    # We want: rest-goals new-subst succ fail db counter

    # Rearrange: swap to get new-subst rest-goals order correct
    swap             # Stack: goals subst succ fail db counter rest-goals new-subst (8 items)
    # idx: 7=goals 6=subst 5=succ 4=fail 3=db 2=counter 1=rest-goals 0=new-subst

    # Copy values we need
    6 pick           # succ (at idx 5+1=6 after our swap made 8 items)
    6 pick           # fail (at idx 4+2=6)
    6 pick           # db (at idx 3+3=6)
    6 pick           # counter (at idx 2+4=6)
    # Stack: goals subst succ fail db counter rest-goals new-subst succ fail db counter (12 items)
    # idx: 11=goals 10=subst 9=succ 8=fail 7=db 6=counter 5=rest-goals 4=new-subst 3=succ' 2=fail' 1=db' 0=counter'

    # Drop the original 6 items (goals subst succ fail db counter)
    # They're at positions 6-11, so roll each to top and drop
    11 roll drop     # drop goals (now 11 items)
    10 roll drop     # drop subst (now 10 items)
    9 roll drop      # drop succ (now 9 items)
    8 roll drop      # drop fail (now 8 items)
    7 roll drop      # drop db (now 7 items)
    6 roll drop      # drop counter (now 6 items)
    # Stack: rest-goals new-subst succ' fail' db' counter' (6 items)

    # Reorder for solve-cps which expects: goals subst succ fail db counter
    # We have: rest-goals new-subst succ fail db counter - correct order!
    solve-cps
  else
    # Builtin failed - call failure continuation
    # Stack: goals subst succ fail db counter result (7 items)
    # idx: 6=goals 5=subst 4=succ 3=fail 2=db 1=counter 0=result
    drop             # drop result (6 items)
    drop             # drop counter (5 items)
    drop             # drop db (4 items)
    # Stack: goals subst succ fail (4 items)
    # idx: 3=goals 2=subst 1=succ 0=fail
    # Need just fail on stack
    nip              # drop succ (3 items: goals subst fail)
    nip              # drop subst (2 items: goals fail)
    nip              # drop goals (1 item: fail)
    call             # fail() -> SolveResult
  then
;

# ============================================
# Clause Matching with Backtracking
# ============================================

# try-clauses-cps: Try each matching clause, with backtracking via closures
# Stack: goals subst succ fail db counter matching
: try-clauses-cps ( GoalList Subst SuccCont FailCont ClauseDB Int ClauseDB -- SolveResult )
  dup db-empty? if
    # No more clauses - call failure continuation
    # Stack: goals subst succ fail db counter matching
    drop             # drop matching
    drop             # drop counter
    drop             # drop db
    nip nip nip      # drop succ, subst, goals - keep fail
    call             # fail() -> SolveResult
  else
    # Try first clause
    try-first-clause-cps
  then
;

# try-first-clause-cps: Try unifying with first clause
# Stack: goals subst succ fail db counter matching
: try-first-clause-cps ( GoalList Subst SuccCont FailCont ClauseDB Int ClauseDB -- SolveResult )
  # Get first clause and rename
  dup db-first       # Stack: ...matching clause
  2 pick             # get counter
  rename-clause      # Stack: goals subst succ fail db counter matching renamed new-counter

  # Unify goal with clause head
  over clause-head   # Stack: ... head
  9 pick gcar        # first goal
  9 pick             # subst
  unify
  # Stack: goals subst succ fail db counter matching renamed new-counter result

  dup unify-ok? if
    unify-ok-subst
    # Stack: goals subst succ fail db counter matching renamed new-counter new-subst
    unify-success-cps
  else
    # Unification failed - try next clause
    # Stack: goals subst succ fail db counter matching renamed new-counter result
    drop             # drop result
    drop             # drop new-counter
    drop             # drop renamed
    db-rest          # remaining clauses
    try-clauses-cps
  then
;

# unify-success-cps: Unification succeeded, continue solving with clause body
# Stack: goals subst succ fail db counter matching renamed new-counter new-subst (10 items)
: unify-success-cps ( GoalList Subst SuccCont FailCont ClauseDB Int ClauseDB Clause Int Subst -- SolveResult )
  # Build combined goals: clause-body ++ rest-of-goals
  # Indices: 9=goals 8=subst 7=succ 6=fail 5=db 4=counter 3=matching 2=renamed 1=new-counter 0=new-subst
  2 pick clause-body   # body from renamed (11 items)
  10 pick gcdr         # rest of original goals (12 items)
  gappend              # combined (11 items)
  # Stack: goals subst succ fail db counter matching renamed new-counter new-subst combined
  # Indices: 10=goals 9=subst 8=succ 7=fail 6=db 5=counter 4=matching 3=renamed 2=new-counter 1=new-subst 0=combined

  # solve-cps needs: goals subst succ fail db counter
  # We want: combined new-subst succ fail db new-counter

  # Copy the values we need to top of stack
  dup              # combined (12 items)
  2 pick           # new-subst (was at 1, now at 2) (13 items)
  10 pick          # succ (was at 8, now at 10) (14 items)
  10 pick          # fail (was at 7, now at 10) (15 items)
  10 pick          # db (was at 6, now at 10) (16 items)
  7 pick           # new-counter (was at 2, now at 7) (17 items)
  # Stack: goals subst succ fail db counter matching renamed new-counter new-subst combined combined' new-subst' succ' fail' db' new-counter'
  # Indices: 16=goals 15=subst 14=succ 13=fail 12=db 11=counter 10=matching 9=renamed 8=new-counter 7=new-subst 6=combined
  #          5=combined' 4=new-subst' 3=succ' 2=fail' 1=db' 0=new-counter'

  # Drop the original 11 items (indices 6-16)
  16 roll drop     # drop goals (16 items)
  15 roll drop     # drop subst (15 items)
  14 roll drop     # drop succ (14 items)
  13 roll drop     # drop fail (13 items)
  12 roll drop     # drop db (12 items)
  11 roll drop     # drop counter (11 items)
  10 roll drop     # drop matching (10 items)
  9 roll drop      # drop renamed (9 items)
  8 roll drop      # drop new-counter (8 items)
  7 roll drop      # drop new-subst (7 items)
  6 roll drop      # drop combined (6 items)

  # Stack: combined' new-subst' succ' fail' db' new-counter' (6 items)
  # This is the correct order for solve-cps: goals subst succ fail db counter
  solve-cps
;
