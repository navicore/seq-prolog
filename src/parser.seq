# Parser for SeqProlog - Recursive Descent
#
# Grammar:
#   program  ::= (clause | query)*
#   clause   ::= term '.' | term ':-' goals '.'
#   query    ::= '?-' goals '.'
#   goals    ::= term (',' term)*
#   term     ::= atom | variable | number | compound | list
#   compound ::= atom '(' args ')'
#   args     ::= term (',' term)*
#   list     ::= '[]' | '[' items ']' | '[' items '|' term ']'
#   items    ::= term (',' term)*

include "tokenizer"

# ============================================
# Parser State
# ============================================

# Variable counter for generating unique IDs
# We use a simple counter that increments for each new variable

# Parse result types are defined in term.seq:
# union ParseResult {
#   ParseOkTerm { term: Term, remaining: TokenList }
#   ParseOkClause { clause: Clause, remaining: TokenList }
#   ParseOkQuery { goals: GoalList, remaining: TokenList }
#   ParseErr { message: String, span: SourceSpan }
# }

# ============================================
# Token Helpers
# ============================================

: peek-text ( TokenList -- String )
  dup tnil? if
    drop ""
  else
    tcar-text
  then
;

: peek-span ( TokenList -- SourceSpan )
  dup tnil? if
    drop no-span
  else
    tcar-span
  then
;

: expect-token ( TokenList String -- TokenList ParseResult )
  over peek-text over string.equal? if
    drop
    dup tcdr swap tcar
    dup tok-text swap tok-span
    tatom-at
    over make-parse-ok-term
  else
    # Build error message
    "Expected '" swap string.concat "'" string.concat
    # Stack: TokenList errorMsg
    over peek-span
    # Stack: TokenList errorMsg SourceSpan
    make-parse-err
    # Stack: TokenList ParseResult
  then
;

# ============================================
# Main Parse Entry Points
# ============================================

# Parse a string into clauses/queries
: parse ( String -- ParseResult )
  tokenize
  parse-input
;

# Parse tokenized input
: parse-input ( TokenList -- ParseResult )
  dup tnil? if
    "Empty input" no-span make-parse-err nip
  else
    dup peek-text "?-" string.equal? if
      parse-query
    else
      parse-clause
    then
  then
;

# ============================================
# Query Parsing
# ============================================

: parse-query ( TokenList -- ParseResult )
  # Skip '?-'
  tcdr
  0  # var counter
  parse-goals
  # Stack: ParseResult (parse-goals nips the counter)
  dup parse-ok-term? if
    # Goals are wrapped in a term - extract and convert to GoalList
    dup parse-term-value
    swap parse-term-remaining
    # Stack: Term remaining
    dup peek-text "." string.equal? if
      tcdr
      # Stack: Term remaining'
      swap term-to-goals
      # Stack: remaining' GoalList
      swap make-parse-ok-query
      # Stack: QueryResult
    else
      drop drop
      "Expected '.' at end of query" no-span make-parse-err
    then
  else
    # Error - propagate, just return the error result
  then
;

# Convert comma-separated term to goal list
: term-to-goals ( Term -- GoalList )
  dup tcompound? if
    dup tcompound-functor "," string.equal? if
      dup tcompound-args
      dup tlcar term-to-goals
      swap tlcdr tlcar term-to-goals
      gappend nip
    else
      gnull gcons
    then
  else
    gnull gcons
  then
;

# ============================================
# Clause Parsing
# ============================================

: parse-clause ( TokenList -- ParseResult )
  0  # var counter
  parse-term-with-counter
  # Stack: ParseResult counter
  over parse-ok-term? if
    over parse-term-value
    2 pick parse-term-remaining
    # Stack: ParseResult counter HeadTerm remaining
    dup peek-text
    dup "." string.equal? if
      # FACT: term '.'
      drop tcdr
      # Stack: ParseResult counter HeadTerm remaining'
      swap make-fact  # Stack: ParseResult counter remaining' Clause
      swap make-parse-ok-clause  # Stack: ParseResult counter ClauseResult
      nip nip  # Stack: ClauseResult
    else
      ":-" string.equal? if
        # RULE: term ':-' body '.'
        tcdr
        # Stack: ParseResult counter HeadTerm body_tokens
        rot
        # Stack: ParseResult HeadTerm body_tokens counter
        parse-goals-with-counter
        # Stack: ParseResult HeadTerm BodyResult new_counter
        drop  # drop counter
        # Stack: ParseResult HeadTerm BodyResult
        dup parse-ok-term? if
          dup parse-term-value term-to-goals
          swap parse-term-remaining
          # Stack: ParseResult HeadTerm BodyGoals remaining
          dup peek-text "." string.equal? if
            tcdr
            # Stack: ParseResult HeadTerm BodyGoals remaining'
            rot rot  # Stack: ParseResult remaining' HeadTerm BodyGoals
            make-clause  # Stack: ParseResult remaining' Clause
            swap make-parse-ok-clause  # Stack: ParseResult ClauseResult
            nip  # Stack: ClauseResult
          else
            drop drop drop drop
            "Expected '.' at end of clause" no-span make-parse-err
          then
        else
          # Body parse error
          nip nip  # Stack: BodyResult (error)
        then
      else
        # Expected '.' or ':-'
        drop drop drop drop
        "Expected '.' or ':-'" no-span make-parse-err
      then
    then
  else
    # Head parse error
    nip  # Stack: ParseResult (error)
  then
;

# ============================================
# Goals Parsing (comma-separated terms)
# ============================================

: parse-goals ( TokenList Int -- ParseResult )
  parse-goals-with-counter nip
;

: parse-goals-with-counter ( TokenList Int -- ParseResult Int )
  parse-term-with-counter
  # Stack: result counter
  over parse-ok-term? if
    over parse-term-remaining
    # Stack: result counter remaining
    dup peek-text "," string.equal? if
      tcdr
      # Stack: result counter remaining'
      rot  # Stack: counter remaining' result
      parse-term-value  # Stack: counter remaining' first-term
      rot rot  # Stack: remaining' first-term counter -> first-term counter remaining'
      swap  # Stack: first-term remaining' counter
      parse-goals-with-counter
      # Stack: first-term rest-result rest-counter
      over parse-ok-term? if
        over parse-term-value  # Stack: first-term rest-result rest-counter rest-term
        2 pick parse-term-remaining  # Stack: first-term rest-result rest-counter rest-term remaining
        4 roll  # Stack: rest-result rest-counter rest-term remaining first-term
        rot  # Stack: rest-result rest-counter remaining first-term rest-term
        tl2 "," swap no-span tcompound-at  # Stack: rest-result rest-counter remaining comma-term
        swap make-parse-ok-term  # Stack: rest-result rest-counter new-result
        rot drop  # Stack: rest-counter new-result
        swap  # Stack: new-result rest-counter
      else
        # Stack: first-term rest-result rest-counter (rest-result is error)
        rot drop  # Stack: rest-result rest-counter
      then
    else
      # No more goals
      drop  # Stack: result counter
    then
  else
    # Error - propagate, stack already has: result counter
  then
;

# ============================================
# Term Parsing
# ============================================

: parse-term-with-counter ( TokenList Int -- ParseResult Int )
  over tnil? if
    drop  # drop empty TokenList
    "Unexpected end of input" no-span make-parse-err
    swap  # Stack: ParseErr Int
  else
    over peek-text
    dup is-variable-token? if
      drop
      parse-variable
    else
      dup is-number-token? if
        drop parse-number
      else
        dup "[" string.equal? if
          drop parse-list
        else
          dup is-atom-token? if
            drop parse-atom-or-compound
          else
            drop  # drop the text
            "Unexpected token: " over peek-text string.concat
            over peek-span make-parse-err
            # Stack: TokenList Int ParseErr
            rot drop  # drop TokenList
            swap  # Stack: ParseErr Int
          then
        then
      then
    then
  then
;

# ============================================
# Variable Parsing
# ============================================

: is-variable-token? ( String -- Bool )
  dup string.empty? if
    drop false
  else
    0 string.char-at
    dup is-uppercase? swap 95 i.= or  # uppercase or _
  then
;

: parse-variable ( TokenList Int -- ParseResult Int )
  over tcar
  dup tok-text
  swap tok-span
  # Stack: tokens counter name span
  2 pick  # counter
  # Stack: tokens counter name span counter
  # tvar-at expects ( String Int SourceSpan -- Term ), so reorder
  swap  # tokens counter name counter span
  tvar-at
  # Stack: tokens counter Term
  rot tcdr  # move tokens to top, get remaining
  # Stack: counter Term remaining
  make-parse-ok-term
  # Stack: counter ParseResult
  swap 1 i.+  # Stack: ParseResult counter+1
;

# ============================================
# Number Parsing
# ============================================

: is-number-token? ( String -- Bool )
  dup string.empty? if
    drop false
  else
    dup 0 string.char-at
    # Stack: String firstChar
    dup is-digit? if
      drop drop true
    else
      45 i.= if  # '-' (negative number)
        # Stack: String
        dup string.length 1 i.> if
          1 string.char-at is-digit?
        else
          drop false
        then
      else
        drop false
      then
    then
  then
;

: parse-number ( TokenList Int -- ParseResult Int )
  swap  # Int TokenList
  dup tcar
  dup tok-text
  swap tok-span
  # Stack: Int TokenList Token text span
  # Check if float (contains '.')
  over "." string.contains? if
    swap string->float drop  # value (ignore success flag for now)
    swap tfloat-at
  else
    swap string->int drop  # value (ignore success flag for now)
    swap tint-at
  then
  # Stack: Int TokenList term
  swap tcdr  # Int remaining term
  make-parse-ok-term  # Int ParseResult
  swap  # ParseResult Int
;

# ============================================
# Atom/Compound Parsing
# ============================================

: is-atom-token? ( String -- Bool )
  dup string.empty? if
    drop false
  else
    0 string.char-at is-lowercase?
  then
;

# Check if next token is "("
: followed-by-paren? ( TokenList -- Bool )
  tcdr dup tnil? if
    drop false
  else
    peek-text "(" string.equal?
  then
;

# Parse a simple atom (no arguments)
: parse-simple-atom ( TokenList Int -- ParseResult Int )
  over tcar
  dup tok-text swap tok-span
  # Stack: tokens counter name span
  tatom-at
  # Stack: tokens counter atom
  rot tcdr
  # Stack: counter atom remaining
  make-parse-ok-term swap
;

# Build compound from functor, args list, and span
: build-compound ( String TermList SourceSpan -- Term )
  tcompound-at
;

# Helper to build compound from stack after parsing args
# Input:  tokens counter functor-name functor-span args-list remaining new-counter
# Output: result new-counter
: build-compound-from-stack ( TokenList Int String SourceSpan TermList TokenList Int -- ParseResult Int )
  # Stack positions (0 = top):
  #   0: new-counter (Int)
  #   1: remaining (TokenList)
  #   2: args-list (TermList)
  #   3: functor-span (SourceSpan)
  #   4: functor-name (String)
  #   5: counter (Int) - old counter, to be dropped
  #   6: tokens (TokenList) - original tokens, to be dropped

  # Step 1: Reverse args-list (need to get it to top first)
  rot                    # top3: args-list remaining new-counter -> remaining new-counter args-list
  reverse-termlist       # Stack: tokens counter functor-name functor-span remaining new-counter reversed-args

  # Step 2: Build compound term using tcompound-at ( String TermList SourceSpan -- Term )
  # Positions: 0:reversed-args 1:new-counter 2:remaining 3:functor-span 4:functor-name 5:counter 6:tokens
  # Need: functor-name reversed-args functor-span (functor-span on top)

  4 roll                 # bring functor-name to top
  swap                   # swap with reversed-args
  4 roll                 # bring functor-span to top
  tcompound-at           # tokens counter remaining new-counter compound

  # Step 3: Build ParseResult
  # make-parse-ok-term ( Term TokenList -- ParseResult ) - Term deeper, TokenList on top
  # Current: tokens counter remaining new-counter compound
  # Need: compound remaining (remaining on top)

  rot                    # top3: remaining new-counter compound -> new-counter compound remaining
  # Stack: tokens counter new-counter compound remaining
  make-parse-ok-term     # tokens counter new-counter result

  # Step 4: Clean up - drop old counter and tokens
  swap                   # tokens counter result new-counter
  rot drop               # drop old counter: tokens result new-counter
  rot drop               # drop original tokens: result new-counter
;

# Parse compound term: functor(arg1, arg2, ...)
: parse-compound ( TokenList Int -- ParseResult Int )
  # Get functor name and span from first token
  over tcar tok-text     # functor name
  2 pick tcar tok-span   # functor span
  # Stack: tokens counter functor-name functor-span

  # Skip past functor and "(" to get to args
  3 pick tcdr tcdr       # args-tokens (after functor and open paren)
  # Stack: tokens counter functor-name functor-span args-tokens
  # Positions: 4       3        2            1           0
  3 pick                 # get counter copy (at position 3, not 4!)
  # Stack: tokens counter functor-name functor-span args-tokens counter

  # Parse the argument list
  parse-arg-list
  # Stack: tokens counter functor-name functor-span args-list remaining new-counter

  # Reverse args and build compound
  # tcompound-at ( String TermList SourceSpan -- Term )
  build-compound-from-stack
;

# Parse argument list, expecting ")" at end
# Returns result containing term list and remaining tokens (after ")")
: parse-arg-list ( TokenList Int -- TermList TokenList Int )
  tlnil
  # Stack: tokens counter empty-list
  rot rot
  # Stack: empty-list tokens counter
  collect-args
;

# Collect args into a list, consuming ")" at the end
: collect-args ( TermList TokenList Int -- TermList TokenList Int )
  parse-term-with-counter
  # Stack: list result counter
  over parse-ok-term? if
    # Got a term, add to list
    over parse-term-value
    # Stack: list result counter term
    3 roll
    # Stack: result counter term list
    tlcons
    # Stack: result counter new-list
    rot parse-term-remaining
    # Stack: counter new-list remaining
    rot
    # Stack: new-list remaining counter

    # Check for more args
    over peek-text
    dup ")" string.equal? if
      drop
      # Done - consume ")" and return
      swap tcdr swap
      # Stack: new-list remaining' counter
    else
      "," string.equal? if
        # More args
        swap tcdr swap
        # Stack: new-list remaining' counter
        collect-args
      else
        # Error - unexpected token, return what we have
        # Stack already: new-list remaining counter
      then
    then
  else
    # Error from parsing term
    # Stack: list result counter
    # Return list we have so far, with remaining from result
    swap parse-term-remaining swap
    # Stack: list remaining counter
  then
;

# Reverse a term list (args are collected in reverse order)
: reverse-termlist ( TermList -- TermList )
  tlnil reverse-termlist-loop
;

: reverse-termlist-loop ( TermList TermList -- TermList )
  over tlnil? if
    nip
  else
    over tlcar
    # Stack: old acc head
    swap tlcons
    # Stack: old new-acc
    swap tlcdr swap
    # Stack: old-rest new-acc
    reverse-termlist-loop
  then
;

# Build comma term from term list (for args)
: termlist-to-comma ( TermList -- Term )
  dup tlnil? if
    drop "nil" no-span tatom-at
  else
    dup tlcdr tlnil? if
      # Single element
      tlcar
    else
      # Multiple elements - build comma structure
      dup tlcar
      swap tlcdr termlist-to-comma
      # Stack: first rest-comma
      tl2 "," swap no-span tcompound-at
    then
  then
;

: parse-atom-or-compound ( TokenList Int -- ParseResult Int )
  over followed-by-paren? if
    parse-compound
  else
    parse-simple-atom
  then
;

# Convert comma-separated term to term list
: termlist-from-comma ( Term -- TermList )
  dup tcompound? if
    dup tcompound-functor "," string.equal? if
      # Comma term: extract first arg, recurse on second
      dup tcompound-args tlcar
      # Stack: Term firstArg
      swap tcompound-args tlcdr tlcar termlist-from-comma
      # Stack: firstArg restTermList
      tlcons
    else
      tlnil tlcons
    then
  else
    tlnil tlcons
  then
;

# ============================================
# Argument List Parsing
# ============================================

: parse-args-with-counter ( TokenList Int -- ParseResult Int )
  parse-term-with-counter
  # Stack: ParseResult Int
  over parse-ok-term? if
    over parse-term-remaining
    # Stack: ParseResult Int remaining
    dup peek-text "," string.equal? if
      tcdr
      # Stack: ParseResult Int remaining'
      rot  # Stack: Int remaining' ParseResult
      parse-term-value  # Stack: Int remaining' Term
      rot rot  # Stack: remaining' Term Int -> Term Int remaining'
      swap  # Stack: Term remaining' Int
      parse-args-with-counter
      # Stack: Term result counter
      over parse-ok-term? if
        over parse-term-value  # Stack: Term result counter rest-term
        2 pick parse-term-remaining  # Stack: Term result counter rest-term remaining
        4 roll  # Stack: result counter rest-term remaining Term
        swap rot  # Stack: result counter remaining Term rest-term
        tl2 "," swap no-span tcompound-at  # Stack: result counter remaining comma-term
        swap make-parse-ok-term  # Stack: result counter new-result
        rot drop  # Stack: counter new-result
        swap  # Stack: new-result counter
      else
        # Stack: Term result counter (result is error)
        rot drop  # Stack: result counter
      then
    else
      # No more args
      drop  # Stack: ParseResult Int
    then
  else
    # Error - Stack: ParseResult Int (already correct)
  then
;

# ============================================
# List Parsing
# ============================================

: parse-list ( TokenList Int -- ParseResult Int )
  # TODO: List parsing not yet fully implemented
  # For now, just return an empty list for []
  over tcdr  # remaining after '['
  # Stack: tokens counter remaining
  dup peek-text "]" string.equal? if
    # Empty list: []
    tcdr  # skip ']'
    # Stack: tokens counter remaining'
    rot drop  # drop original tokens
    # Stack: counter remaining'
    tempty-list  # Stack: counter remaining' EmptyListTerm
    swap make-parse-ok-term  # Stack: counter ParseResult
    swap  # Stack: ParseResult counter
  else
    # Non-empty list - not implemented yet
    drop drop drop
    "List syntax not yet implemented" no-span make-parse-err
    0
  then
;

: parse-list-items ( TokenList Int -- ParseResult Int )
  parse-term-with-counter
  # Stack: ParseResult Int
  over parse-ok-term? if
    over parse-term-remaining
    # Stack: ParseResult Int remaining
    dup peek-text "," string.equal? if
      tcdr
      # Stack: ParseResult Int remaining'
      rot  # Stack: Int remaining' ParseResult
      parse-term-value  # Stack: Int remaining' Term
      rot rot  # Stack: remaining' Term Int -> Term Int remaining'
      swap  # Stack: Term remaining' Int
      parse-list-items
      # Stack: Term result counter
      over parse-ok-term? if
        over parse-term-value  # Stack: Term result counter rest-term
        2 pick parse-term-remaining  # Stack: Term result counter rest-term remaining
        4 roll  # Stack: result counter rest-term remaining Term
        swap rot  # Stack: result counter remaining Term rest-term
        tl2 "," swap no-span tcompound-at  # Stack: result counter remaining comma-term
        swap make-parse-ok-term  # Stack: result counter new-result
        rot drop  # Stack: counter new-result
        swap  # Stack: new-result counter
      else
        # Stack: Term result counter (result is error)
        rot drop  # Stack: result counter
      then
    else
      drop  # Stack: ParseResult Int
    then
  else
    # Stack: ParseResult Int (error result)
  then
;

# Convert term list to proper Prolog list (ending with [])
: termlist-to-proper-list ( TermList -- Term )
  dup tlnil? if
    drop tempty-list
  else
    dup tlcar
    swap tlcdr termlist-to-proper-list
    tlist
  then
;

# Convert term list to improper list with given tail
: termlist-to-improper-list ( TermList Term -- Term )
  swap
  dup tlnil? if
    drop
  else
    dup tlcar
    swap tlcdr
    rot  # head rest tail
    termlist-to-improper-list
    tlist
  then
;

# Replace span in a list term
: tlist-replace-span ( Term SourceSpan -- Term )
  over tlist? if
    swap
    dup tlist-head
    swap tlist-tail
    rot tlist-at
  else
    drop
  then
;

# ============================================
# Utility Functions
# ============================================

# Check if string contains a character
: string.contains? ( String String -- Bool )
  swap
  0 string.contains-loop?
;

: string.contains-loop? ( String String Int -- Bool )
  2 pick string.length over i.<= if
    drop drop drop false
  else
    2 pick over 1 string.substring
    2 pick string.equal? if
      drop drop drop true
    else
      1 i.+ string.contains-loop?
    then
  then
;

# ============================================
# Debug Utilities
# ============================================

: print-parse-result ( ParseResult -- )
  dup parse-ok-term? if
    "Term: " parse-term-value term-to-string string.concat io.write-line
  else
    dup parse-ok-clause? if
      "Clause: " parse-clause-value clause-to-string string.concat io.write-line
    else
      dup parse-ok-query? if
        "Query: " parse-query-goals goals-to-string string.concat io.write-line
      else
        "Error: " parse-err-message string.concat io.write-line
      then
    then
  then
;

# ============================================
# Multi-Clause Parsing (for compiler)
# ============================================

# Result type for parsing all clauses
union ParseAllResult {
  ParseAllOk { db: ClauseDB }
  ParseAllErr { message: String }
}

: parse-all-ok? ( ParseAllResult -- Bool )
  match
    ParseAllOk -> drop true
    ParseAllErr -> drop false
  end
;

: parse-all-error ( ParseAllResult -- String )
  0 variant.field-at ;

: parse-all-clauses-db ( ParseAllResult -- ClauseDB )
  0 variant.field-at ;

: make-parse-all-ok ( ClauseDB -- ParseAllResult )
  Make-ParseAllOk ;

: make-parse-all-err ( String -- ParseAllResult )
  Make-ParseAllErr ;

# Parse all clauses from source string
: parse-all-clauses ( String -- ParseAllResult )
  tokenize
  db-empty  # empty clause db
  swap   # Stack: db tokens
  parse-clauses-loop
;

# Loop through tokens, parsing clauses until done
: parse-clauses-loop ( ClauseDB TokenList -- ParseAllResult )
  dup tnil? if
    # Done - all tokens consumed
    drop make-parse-all-ok
  else
    # Try to parse a clause
    parse-clause
    # Stack: db ParseResult
    dup parse-ok-clause? if
      # Got a clause - add to db and continue
      dup parse-clause-value
      # Stack: db ParseResult Clause
      rot
      # Stack: ParseResult Clause db
      db-append
      # Stack: ParseResult db'
      swap parse-clause-remaining
      # Stack: db' remaining
      parse-clauses-loop
    else
      dup parse-ok-query? if
        # Got a query - skip for now (TODO: handle queries)
        parse-query-remaining
        parse-clauses-loop
      else
        # Error
        nip  # drop db
        parse-err-message make-parse-all-err
      then
    then
  then
;
