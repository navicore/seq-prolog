# Code Generation for SeqProlog Compiler
#
# Generates Seq source code from parsed Prolog AST.
# The generated code links against the runtime library.

include "term"

# ============================================
# String Escaping
# ============================================

# Escape special characters in strings for Seq code generation.
# Escapes backslash and double quote to prevent code injection.

: escape-string-loop ( String Int String -- String )
  # Stack: input pos acc
  2 pick string.length 2 pick i.<= if
    # pos >= length: done, return accumulator
    nip nip
  else
    # Get char at input[pos]
    2 pick 2 pick string.char-at
    dup 92 i.= if
      # Backslash (92) -> double it
      drop
      92 char->string 92 char->string string.concat
      string.concat
      swap 1 i.add swap
      escape-string-loop
    else dup 34 i.= if
      # Double quote (34) -> escape with backslash
      drop
      92 char->string 34 char->string string.concat
      string.concat
      swap 1 i.add swap
      escape-string-loop
    else
      # Regular char -> append as-is
      char->string string.concat
      swap 1 i.add swap
      escape-string-loop
    then then
  then
;

: escape-string ( String -- String )
  0 "" escape-string-loop ;

# ============================================
# Term to Seq Code
# ============================================

# Generate Seq code that constructs a term at runtime
: gen-term ( Term -- String )
  dup tatom? if
    # Atoms: "name" no-span tatom-at
    tatom-name escape-string "\"" swap string.concat "\" no-span tatom-at" string.concat
  else
    dup tvar? if
      # Variables: "Name" id no-span tvar-at
      dup tvar-name escape-string
      swap tvar-id int->string
      # Stack: name id-str
      "\"" rot string.concat "\" " string.concat
      swap string.concat " no-span tvar-at" string.concat
    else
      dup tint? if
        # Integers: value no-span tint-at
        tint-value int->string " no-span tint-at" string.concat
      else
        dup tcompound? if
          # Compound terms: need to generate args first, then functor
          dup tcompound-functor escape-string
          swap tcompound-args gen-termlist
          # Stack: functor args-code
          swap "\"" swap string.concat "\" " string.concat
          swap string.concat " no-span tcompound-at" string.concat
        else
          drop "# unsupported term type"
        then
      then
    then
  then
;

# Generate code for a term list (builds tlcons chain)
: gen-termlist ( TermList -- String )
  dup tlnil? if
    drop "tlnil"
  else
    dup tlcar gen-term
    swap tlcdr gen-termlist
    # Stack: head-code tail-code
    swap " " string.concat swap string.concat " tlcons" string.concat
  then
;

# ============================================
# Clause Generation
# ============================================

# Generate code for a single clause (fact or rule)
: gen-clause ( Clause -- String )
  dup clause-head gen-term
  swap clause-body
  dup gnull? if
    # Fact: just the head, empty body
    drop " gnull make-clause" string.concat
  else
    # Rule: head and body goals
    gen-goallist
    swap " " string.concat swap string.concat " make-clause" string.concat
  then
;

: gen-goallist ( GoalList -- String )
  dup gnull? if
    drop "gnull"
  else
    dup gcar gen-term
    swap gcdr gen-goallist
    swap " " string.concat swap string.concat " gcons" string.concat
  then
;

# ============================================
# Program Generation
# ============================================

# Generate the full program from a list of clauses
: gen-program ( ClauseDB String -- String )
  # ClauseDB is the parsed clauses
  # String is the query (if any) - currently unused, queries come from --query arg
  # Returns complete Seq source code
  drop  # drop unused query string

  # Header - include runtime/query which provides CLI query execution
  "# Generated by SeqProlog Compiler\n"
  "include \"runtime/query\"\n\n" string.concat

  # Clause database builder
  ": init-clauses ( -- ClauseDB )\n" string.concat
  "  db-empty\n" string.concat

  # Generate each clause
  swap gen-all-clauses string.concat

  ";\n\n" string.concat

  # Main function - initialize clauses and run CLI query
  ": main ( -- )\n" string.concat
  "  init-clauses run-cli-query\n" string.concat
  ";\n" string.concat
;

: gen-all-clauses ( ClauseDB -- String )
  dup db-empty? if
    drop ""
  else
    dup db-first gen-clause
    # Use swap db-append to preserve clause order
    # (stack has ClauseDB below, Clause on top; db-append needs Clause below)
    "  " swap string.concat " swap db-append\n" string.concat
    swap db-rest gen-all-clauses
    string.concat
  then
;
