# Prolog Term Data Types for SeqProlog
#
# Algebraic Data Types for Prolog terms:
#
#   Term i.= TAtom String | TVar String Int | TCompound String TermList
#        | TInt Int | TFloat Float | TList Term Term
#   TermList i.= TLNil | TLCons Term TermList
#   Clause i.= Clause Term GoalList
#   GoalList i.= GNil | GCons Term GoalList
#   ClauseDB i.= DBEmpty | DBCons Clause ClauseDB
#   Subst i.= SubstEmpty | SubstExtend Binding Subst
#   Binding i.= Bind Int Term
#
# All types are defined here to support mutual recursion.

# ============================================
# Source Location (for error reporting)
# ============================================

union SourceSpan {
  NoSpan
  Span { start_line: Int, start_col: Int, end_line: Int, end_col: Int }
}

: no-span ( -- SourceSpan )
  Make-NoSpan ;

: make-span ( Int Int Int Int -- SourceSpan )
  Make-Span ;

: span? ( SourceSpan -- Bool )
  match
    NoSpan -> false
    Span -> drop drop drop drop true
  end
;

: no-span? ( SourceSpan -- Bool )
  match
    NoSpan -> true
    Span -> drop drop drop drop false
  end
;

: span-start-line ( SourceSpan -- Int )
  0 variant.field-at ;

: span-start-col ( SourceSpan -- Int )
  1 variant.field-at ;

: span-end-line ( SourceSpan -- Int )
  2 variant.field-at ;

: span-end-col ( SourceSpan -- Int )
  3 variant.field-at ;

# Combine two spans into one covering both
: span-combine ( SourceSpan SourceSpan -- SourceSpan )
  over no-span? if
    nip
  else
    dup no-span? if
      drop
    else
      over span-start-line
      2 pick span-start-col
      2 pick span-end-line
      3 pick span-end-col
      make-span nip nip
    then
  then
;

# ============================================
# Prolog Terms
# ============================================

# Forward declarations for mutual recursion
union TermList {
  TLNil
  TLCons { head: Term, tail: TermList }
}

# Prolog terms
# Tags: 0=TAtom, 1=TVar, 2=TCompound, 3=TInt, 4=TFloat, 5=TList
union Term {
  TAtom { name: String, span: SourceSpan }
  TVar { name: String, id: Int, span: SourceSpan }
  TCompound { functor: String, args: TermList, span: SourceSpan }
  TInt { value: Int, span: SourceSpan }
  TFloat { value: Float, span: SourceSpan }
  TList { head: Term, tail: Term, span: SourceSpan }
}

# ============================================
# Term Constructors
# ============================================

# With explicit span
: tatom-at ( String SourceSpan -- Term )
  Make-TAtom ;

: tvar-at ( String Int SourceSpan -- Term )
  Make-TVar ;

: tcompound-at ( String TermList SourceSpan -- Term )
  Make-TCompound ;

: tint-at ( Int SourceSpan -- Term )
  Make-TInt ;

: tfloat-at ( Float SourceSpan -- Term )
  Make-TFloat ;

: tlist-at ( Term Term SourceSpan -- Term )
  Make-TList ;

# Without span (use NoSpan)
: tatom ( String -- Term )
  no-span tatom-at ;

: tvar ( String Int -- Term )
  no-span tvar-at ;

: tcompound ( String TermList -- Term )
  no-span tcompound-at ;

: tint ( Int -- Term )
  no-span tint-at ;

: tfloat ( Float -- Term )
  no-span tfloat-at ;

: tlist ( Term Term -- Term )
  no-span tlist-at ;

# Empty list atom
: tempty-list ( -- Term )
  "[]" tatom ;

: tempty-list-at ( SourceSpan -- Term )
  "[]" swap tatom-at ;

# ============================================
# Term Predicates
# ============================================

: tatom? ( Term -- Bool )
  match
    TAtom -> drop drop true
    TVar -> drop drop drop false
    TCompound -> drop drop drop false
    TInt -> drop drop false
    TFloat -> drop drop false
    TList -> drop drop drop false
  end
;

: tvar? ( Term -- Bool )
  match
    TAtom -> drop drop false
    TVar -> drop drop drop true
    TCompound -> drop drop drop false
    TInt -> drop drop false
    TFloat -> drop drop false
    TList -> drop drop drop false
  end
;

: tcompound? ( Term -- Bool )
  match
    TAtom -> drop drop false
    TVar -> drop drop drop false
    TCompound -> drop drop drop true
    TInt -> drop drop false
    TFloat -> drop drop false
    TList -> drop drop drop false
  end
;

: tint? ( Term -- Bool )
  match
    TAtom -> drop drop false
    TVar -> drop drop drop false
    TCompound -> drop drop drop false
    TInt -> drop drop true
    TFloat -> drop drop false
    TList -> drop drop drop false
  end
;

: tfloat? ( Term -- Bool )
  match
    TAtom -> drop drop false
    TVar -> drop drop drop false
    TCompound -> drop drop drop false
    TInt -> drop drop false
    TFloat -> drop drop true
    TList -> drop drop drop false
  end
;

: tlist? ( Term -- Bool )
  match
    TAtom -> drop drop false
    TVar -> drop drop drop false
    TCompound -> drop drop drop false
    TInt -> drop drop false
    TFloat -> drop drop false
    TList -> drop drop drop true
  end
;

# Check if term is the empty list atom []
: tempty-list? ( Term -- Bool )
  dup tatom? if
    tatom-name "[]" string.equal?
  else
    drop false
  then
;

# Check if term is a proper list (ends with [])
: tproper-list? ( Term -- Bool )
  dup tempty-list? if
    drop true
  else
    dup tlist? if
      tlist-tail tproper-list?
    else
      drop false
    then
  then
;

# ============================================
# Term Accessors
# ============================================

: tatom-name ( Term -- String )
  0 variant.field-at ;

: tatom-span ( Term -- SourceSpan )
  1 variant.field-at ;

: tvar-name ( Term -- String )
  0 variant.field-at ;

: tvar-id ( Term -- Int )
  1 variant.field-at ;

: tvar-span ( Term -- SourceSpan )
  2 variant.field-at ;

: tcompound-functor ( Term -- String )
  0 variant.field-at ;

: tcompound-args ( Term -- TermList )
  1 variant.field-at ;

: tcompound-span ( Term -- SourceSpan )
  2 variant.field-at ;

: tint-value ( Term -- Int )
  0 variant.field-at ;

: tint-span ( Term -- SourceSpan )
  1 variant.field-at ;

: tfloat-value ( Term -- Float )
  0 variant.field-at ;

: tfloat-span ( Term -- SourceSpan )
  1 variant.field-at ;

: tlist-head ( Term -- Term )
  0 variant.field-at ;

: tlist-tail ( Term -- Term )
  1 variant.field-at ;

: tlist-span ( Term -- SourceSpan )
  2 variant.field-at ;

# Get span from any term
: term-span ( Term -- SourceSpan )
  dup tatom? if tatom-span else
  dup tvar? if tvar-span else
  dup tcompound? if tcompound-span else
  dup tint? if tint-span else
  dup tfloat? if tfloat-span else
  dup tlist? if tlist-span else
  drop no-span
  then then then then then then
;

# ============================================
# TermList Operations
# ============================================

: tlnil ( -- TermList )
  Make-TLNil ;

: tlcons ( Term TermList -- TermList )
  Make-TLCons ;

: tlnil? ( TermList -- Bool )
  match
    TLNil -> true
    TLCons -> drop drop false
  end
;

: tlcar ( TermList -- Term )
  0 variant.field-at ;

: tlcdr ( TermList -- TermList )
  1 variant.field-at ;

# Length of term list
: tllen ( TermList -- Int )
  0 tllen-loop ;

: tllen-loop ( TermList Int -- Int )
  swap dup tlnil? if
    drop
  else
    tlcdr swap 1 i.+ tllen-loop
  then
;

# Reverse term list
: tlrev ( TermList -- TermList )
  tlnil tlrev-loop ;

: tlrev-loop ( TermList TermList -- TermList )
  swap dup tlnil? if
    drop
  else
    dup tlcar swap tlcdr
    rot rot swap tlcons
    tlrev-loop
  then
;

# Build term list from 1-3 terms (convenience)
: tl1 ( Term -- TermList )
  tlnil tlcons ;

: tl2 ( Term Term -- TermList )
  tlnil tlcons tlcons ;

: tl3 ( Term Term Term -- TermList )
  tlnil tlcons tlcons tlcons ;

# ============================================
# Goal List (for clause bodies)
# ============================================

union GoalList {
  GNil
  GCons { goal: Term, rest: GoalList }
}

: gnull ( -- GoalList )
  Make-GNil ;

: gcons ( Term GoalList -- GoalList )
  Make-GCons ;

: gnull? ( GoalList -- Bool )
  match
    GNil -> true
    GCons -> drop drop false
  end
;

: gcar ( GoalList -- Term )
  0 variant.field-at ;

: gcdr ( GoalList -- GoalList )
  1 variant.field-at ;

# Length of goal list
: glen ( GoalList -- Int )
  0 glen-loop ;

: glen-loop ( GoalList Int -- Int )
  swap dup gnull? if
    drop
  else
    gcdr swap 1 i.+ glen-loop
  then
;

# Append two goal lists
: gappend ( GoalList GoalList -- GoalList )
  swap dup gnull? if
    drop
  else
    dup gcar swap gcdr
    rot gappend gcons
  then
;

# Reverse goal list
: grev ( GoalList -- GoalList )
  gnull grev-loop ;

: grev-loop ( GoalList GoalList -- GoalList )
  swap dup gnull? if
    drop
  else
    dup gcar swap gcdr
    rot rot swap gcons
    grev-loop
  then
;

# ============================================
# Clauses (Facts and Rules)
# ============================================

union Clause {
  Clause { head: Term, body: GoalList }
}

: make-clause ( Term GoalList -- Clause )
  Make-Clause ;

# Fact: clause with empty body
: make-fact ( Term -- Clause )
  gnull make-clause ;

: clause-head ( Clause -- Term )
  0 variant.field-at ;

: clause-body ( Clause -- GoalList )
  1 variant.field-at ;

# Check if clause is a fact (empty body)
: clause-fact? ( Clause -- Bool )
  clause-body gnull? ;

# ============================================
# Clause Database
# ============================================

union ClauseDB {
  DBEmpty
  DBCons { clause: Clause, rest: ClauseDB }
}

: db-empty ( -- ClauseDB )
  Make-DBEmpty ;

: db-cons ( Clause ClauseDB -- ClauseDB )
  Make-DBCons ;

: db-empty? ( ClauseDB -- Bool )
  match
    DBEmpty -> true
    DBCons -> drop drop false
  end
;

: db-first ( ClauseDB -- Clause )
  0 variant.field-at ;

: db-rest ( ClauseDB -- ClauseDB )
  1 variant.field-at ;

# Add clause to end of database (for order preservation)
: db-append ( Clause ClauseDB -- ClauseDB )
  dup db-empty? if
    drop db-empty db-cons
  else
    dup db-first
    swap db-rest
    rot swap db-append
    db-cons
  then
;

# Count clauses in database
: db-count ( ClauseDB -- Int )
  0 db-count-loop ;

: db-count-loop ( ClauseDB Int -- Int )
  swap dup db-empty? if
    drop
  else
    db-rest swap 1 i.+ db-count-loop
  then
;

# ============================================
# ClauseDB Reversal (needed by index building)
# ============================================

# Reverse a ClauseDB list
: db-reverse ( ClauseDB -- ClauseDB )
  db-empty db-reverse-loop ;

: db-reverse-loop ( ClauseDB ClauseDB -- ClauseDB )
  # Stack: input(1) acc(0)
  over db-empty? if
    nip
  else
    over db-first          # input acc first
    swap db-cons           # input new-acc
    swap db-rest swap      # rest-input new-acc
    db-reverse-loop
  then
;

# ============================================
# Predicate Index (for fast clause lookup)
# ============================================

# --- String hashing for bucket indexing ---

# Compute a simple hash of a string, returning 0..255
# Uses sum of character codes with mixing
: string-hash ( String -- Int )
  0 0 string-hash-loop 256 i.% drop ;

: string-hash-loop ( String Int Int -- Int )
  # Stack: str(2) pos(1) acc(0)
  2 pick string.length over i.<= if
    nip nip  # pos >= length, return acc
  else
    2 pick over string.char-at  # str pos acc char
    i.+                          # str pos new-acc
    swap 1 i.+ swap              # str pos+1 new-acc
    string-hash-loop
  then
;

# --- Flat bucket: association list within a hash bucket ---

union FlatBucket {
  FBEmpty
  FBCons { key: String, clauses: ClauseDB, rest: FlatBucket }
}

: fb-empty ( -- FlatBucket ) Make-FBEmpty ;
: fb-cons ( String ClauseDB FlatBucket -- FlatBucket ) Make-FBCons ;

: fb-empty? ( FlatBucket -- Bool )
  match
    FBEmpty -> true
    FBCons -> drop drop drop false
  end
;

: fb-key ( FlatBucket -- String ) 0 variant.field-at ;
: fb-clauses ( FlatBucket -- ClauseDB ) 1 variant.field-at ;
: fb-rest ( FlatBucket -- FlatBucket ) 2 variant.field-at ;

# Lookup in flat bucket by exact key
: fb-lookup ( String FlatBucket -- ClauseDB Bool )
  dup fb-empty? if
    drop drop db-empty false
  else
    dup fb-key
    2 pick string.equal? if
      nip fb-clauses true
    else
      fb-rest fb-lookup
    then
  then
;

# Prepend clause to matching key's list (or create new entry)
: fb-add ( String Clause FlatBucket -- FlatBucket )
  # Stack: key(2) clause(1) bucket(0)
  dup fb-empty? if
    drop
    db-empty db-cons
    fb-empty fb-cons
  else
    dup fb-key
    3 pick string.equal? if
      # Match - prepend clause
      swap
      over fb-clauses
      db-cons
      swap fb-rest
      fb-cons
    else
      # No match - recurse on rest
      dup fb-rest
      3 pick
      3 pick
      rot
      fb-add
      swap dup fb-key
      swap fb-clauses
      rot
      fb-cons
      nip nip
    then
  then
;

# Reverse all clause lists in a flat bucket
: fb-reverse-all ( FlatBucket -- FlatBucket )
  dup fb-empty? if
  else
    dup fb-key
    over fb-clauses db-reverse
    rot fb-rest fb-reverse-all
    fb-cons
  then
;

# --- Hash-bucketed ArgIndex: 256-slot hash table ---
# Implemented as a balanced binary trie of depth 8 (256 leaves)

union ArgIndex {
  AILeaf { bucket: FlatBucket }
  AINode { left: ArgIndex, right: ArgIndex }
}

: ai-leaf ( FlatBucket -- ArgIndex ) Make-AILeaf ;
: ai-node ( ArgIndex ArgIndex -- ArgIndex ) Make-AINode ;

: ai-leaf? ( ArgIndex -- Bool )
  match
    AILeaf -> drop true
    AINode -> drop drop false
  end
;

: ai-leaf-bucket ( ArgIndex -- FlatBucket ) 0 variant.field-at ;
: ai-node-left ( ArgIndex -- ArgIndex ) 0 variant.field-at ;
: ai-node-right ( ArgIndex -- ArgIndex ) 1 variant.field-at ;

# Build empty trie of given depth
: ai-make-empty ( Int -- ArgIndex )
  dup 0 i.<= if
    drop fb-empty ai-leaf
  else
    1 i.-
    dup ai-make-empty
    swap ai-make-empty
    ai-node
  then
;

# Build standard empty 256-slot ArgIndex
: ai-empty ( -- ArgIndex )
  8 ai-make-empty ;

# --- Trie navigation helper (read-only, one level) ---
# Takes one step down the trie based on lowest hash bit
: ai-nav ( Int ArgIndex -- Int ArgIndex )
  # Stack: hash(1) node(0)
  over                     # hash node hash
  2 i.% drop               # hash node bit
  0 i.= if
    ai-node-left           # hash child
  else
    ai-node-right          # hash child
  then
  swap 2 i./ drop swap     # hash/2 child
;

# Lookup in hash-bucketed ArgIndex (iterative 8-level descent)
: ai-lookup ( String ArgIndex -- ClauseDB Bool )
  over string-hash swap    # key hash index
  ai-nav ai-nav ai-nav ai-nav ai-nav ai-nav ai-nav ai-nav
  # key hash' leaf
  nip ai-leaf-bucket fb-lookup
;

# Add clause to hash-bucketed ArgIndex
: ai-add ( String Clause ArgIndex -- ArgIndex )
  2 pick string-hash       # key clause index hash
  8 ai-add-rec             # result
;

# Recursive trie add with path rebuilding
# Stack: key(4) clause(3) node(2) hash(1) depth(0)
: ai-add-rec ( String Clause ArgIndex Int Int -- ArgIndex )
  dup 0 i.<= if
    # At leaf - add to flat bucket
    drop drop              # key(2) clause(1) node(0)
    ai-leaf-bucket         # key(2) clause(1) bucket(0)
    fb-add                 # new-bucket
    ai-leaf                # new-leaf
  else
    # At node - check hash bit for direction
    over                   # key(5) clause(4) node(3) hash(2) depth(1) hash-copy(0)
    2 i.% drop             # key(5) clause(4) node(3) hash(2) depth(1) bit(0)
    0 i.= if
      # Go LEFT
      # Stack: key(4) clause(3) node(2) hash(1) depth(0) — 5 items
      # Save right sibling from current node
      2 pick ai-node-right # 6 items: ...right(0)
      # Push recursive call args: key clause left hash/2 depth-1
      5 pick               # 7: copy key
      5 pick               # 8: copy clause
      5 pick ai-node-left  # 9: get left child from node
      5 pick 2 i./ drop    # 10: hash/2
      5 pick 1 i.-         # 11: depth-1
      ai-add-rec           # 7: key(6) clause(5) node(4) hash(3) depth(2) right(1) new-left(0)
      # Rebuild: ai-node(new-left, right)
      swap ai-node         # 6: key(5) clause(4) node(3) hash(2) depth(1) new-node(0)
      nip nip nip nip nip  # 1: new-node
    else
      # Go RIGHT
      # Stack: key(4) clause(3) node(2) hash(1) depth(0) — 5 items
      # Save left sibling from current node
      2 pick ai-node-left  # 6 items: ...left(0)
      # Push recursive call args: key clause right hash/2 depth-1
      5 pick               # 7: copy key
      5 pick               # 8: copy clause
      5 pick ai-node-right # 9: get right child from node
      5 pick 2 i./ drop    # 10: hash/2
      5 pick 1 i.-         # 11: depth-1
      ai-add-rec           # 7: key(6) clause(5) node(4) hash(3) depth(2) left(1) new-right(0)
      # Rebuild: ai-node(left, new-right) — left already deeper on stack
      ai-node              # 6: key(5) clause(4) node(3) hash(2) depth(1) new-node(0)
      nip nip nip nip nip  # 1: new-node
    then
  then
;

# Reverse all clause lists in the entire trie
: ai-reverse-all ( ArgIndex -- ArgIndex )
  dup ai-leaf? if
    ai-leaf-bucket
    fb-reverse-all
    ai-leaf
  else
    dup ai-node-left ai-reverse-all
    swap ai-node-right ai-reverse-all
    ai-node
  then
;

# Predicate entry: all clauses for one functor/arity
union PredicateEntry {
  PredEntry { arg_index: ArgIndex, var_clauses: ClauseDB, all_clauses: ClauseDB }
}

: make-pred-entry ( ArgIndex ClauseDB ClauseDB -- PredicateEntry )
  Make-PredEntry ;

: pred-arg-index ( PredicateEntry -- ArgIndex )
  0 variant.field-at ;

: pred-var-clauses ( PredicateEntry -- ClauseDB )
  1 variant.field-at ;

: pred-all-clauses ( PredicateEntry -- ClauseDB )
  2 variant.field-at ;

# Top-level index: maps "functor/arity" → PredicateEntry
union PredicateIndex {
  PIEmpty
  PICons { key: String, entry: PredicateEntry, rest: PredicateIndex }
}

: pi-empty ( -- PredicateIndex )
  Make-PIEmpty ;

: pi-cons ( String PredicateEntry PredicateIndex -- PredicateIndex )
  Make-PICons ;

: pi-empty? ( PredicateIndex -- Bool )
  match
    PIEmpty -> true
    PICons -> drop drop drop false
  end
;

: pi-key ( PredicateIndex -- String )
  0 variant.field-at ;

: pi-entry ( PredicateIndex -- PredicateEntry )
  1 variant.field-at ;

: pi-rest ( PredicateIndex -- PredicateIndex )
  2 variant.field-at ;

# Lookup a predicate entry by functor/arity key
# Returns ( PredicateEntry Bool )
: pi-lookup ( String PredicateIndex -- PredicateEntry Bool )
  dup pi-empty? if
    drop drop
    ai-empty db-empty db-empty make-pred-entry false
  else
    dup pi-key
    2 pick string.equal? if
      nip pi-entry true
    else
      pi-rest pi-lookup
    then
  then
;

# ============================================
# Variable Bindings and Substitution
# ============================================

union Binding {
  Bind { var_id: Int, value: Term }
}

: make-binding ( Int Term -- Binding )
  Make-Bind ;

: binding-var-id ( Binding -- Int )
  0 variant.field-at ;

: binding-value ( Binding -- Term )
  1 variant.field-at ;

union Subst {
  SubstEmpty
  SubstExtend { binding: Binding, parent: Subst }
}

: subst-empty ( -- Subst )
  Make-SubstEmpty ;

: subst-extend ( Binding Subst -- Subst )
  Make-SubstExtend ;

: subst-empty? ( Subst -- Bool )
  match
    SubstEmpty -> true
    SubstExtend -> drop drop false
  end
;

: subst-binding ( Subst -- Binding )
  0 variant.field-at ;

: subst-parent ( Subst -- Subst )
  1 variant.field-at ;

# Add a binding: var_id -> term
: subst-bind ( Int Term Subst -- Subst )
  rot rot make-binding swap subst-extend ;

# Lookup variable in substitution
# Returns: Option<Term> (using Bool flag + value on stack)
: subst-lookup ( Int Subst -- Bool Term )
  dup subst-empty? if
    drop drop false tempty-list  # Not found (dummy term)
  else
    dup subst-binding
    dup binding-var-id
    3 pick i.= if
      binding-value nip nip true swap  # Found
    else
      drop subst-parent subst-lookup
    then
  then
;

# ============================================
# Choice Points for Backtracking
# ============================================

# SolveState bundles subst and counter for choice points
union SolveState {
  SS { subst: Subst, counter: Int }
}

: make-solve-state ( Subst Int -- SolveState )
  Make-SS ;

: ss-subst ( SolveState -- Subst )
  0 variant.field-at ;

: ss-counter ( SolveState -- Int )
  1 variant.field-at ;

union ChoicePoint {
  # Choice point for backtracking - saves state to try alternative clauses
  #
  # Fields:
  #   goals: The goal list we're trying to solve (goal::rest format)
  #   untried_clauses: Remaining clauses to try for the current goal
  #                    (excludes the clause we already tried successfully)
  #   full_db: PredicateIndex for fast indexed clause lookup
  #   state: Substitution and variable counter bundled together
  CP { goals: GoalList, untried_clauses: ClauseDB, full_db: PredicateIndex, state: SolveState }
}

: make-cp ( GoalList ClauseDB PredicateIndex Subst Int -- ChoicePoint )
  # Args: goals, untried_clauses, full_db (PredicateIndex), subst, counter
  make-solve-state Make-CP ;

: cp-goals ( ChoicePoint -- GoalList )
  0 variant.field-at ;

: cp-untried-clauses ( ChoicePoint -- ClauseDB )
  # Returns the clauses we haven't tried yet for this goal
  1 variant.field-at ;

: cp-full-db ( ChoicePoint -- PredicateIndex )
  # Returns the predicate index (for recursive solving)
  2 variant.field-at ;

: cp-state ( ChoicePoint -- SolveState )
  3 variant.field-at ;

: cp-subst ( ChoicePoint -- Subst )
  cp-state ss-subst ;

: cp-var-counter ( ChoicePoint -- Int )
  cp-state ss-counter ;

union ChoiceStack {
  CPNil
  CPCons { cp: ChoicePoint, rest: ChoiceStack }
}

: cpnil ( -- ChoiceStack )
  Make-CPNil ;

: cpcons ( ChoicePoint ChoiceStack -- ChoiceStack )
  Make-CPCons ;

: cpnil? ( ChoiceStack -- Bool )
  match
    CPNil -> true
    CPCons -> drop drop false
  end
;

: cpcar ( ChoiceStack -- ChoicePoint )
  0 variant.field-at ;

: cpcdr ( ChoiceStack -- ChoiceStack )
  1 variant.field-at ;

# ============================================
# Solve Result
# ============================================

union SolveResult {
  SolveSuccess { subst: Subst }
  SolveFailure
  SolveError { message: String, span: SourceSpan }
}

: make-solve-success ( Subst -- SolveResult )
  Make-SolveSuccess ;

: make-solve-failure ( -- SolveResult )
  Make-SolveFailure ;

: make-solve-error ( String SourceSpan -- SolveResult )
  Make-SolveError ;

: solve-success? ( SolveResult -- Bool )
  match
    SolveSuccess -> drop true
    SolveFailure -> false
    SolveError -> drop drop false
  end
;

: solve-failure? ( SolveResult -- Bool )
  match
    SolveSuccess -> drop false
    SolveFailure -> true
    SolveError -> drop drop false
  end
;

: solve-error? ( SolveResult -- Bool )
  match
    SolveSuccess -> drop false
    SolveFailure -> false
    SolveError -> drop drop true
  end
;

: solve-success-subst ( SolveResult -- Subst )
  0 variant.field-at ;

: solve-error-message ( SolveResult -- String )
  0 variant.field-at ;

: solve-error-span ( SolveResult -- SourceSpan )
  1 variant.field-at ;

# ============================================
# Unification Result
# ============================================

union UnifyResult {
  UnifyOk { subst: Subst }
  UnifyFail
}

: make-unify-ok ( Subst -- UnifyResult )
  Make-UnifyOk ;

: make-unify-fail ( -- UnifyResult )
  Make-UnifyFail ;

: unify-ok? ( UnifyResult -- Bool )
  match
    UnifyOk -> drop true
    UnifyFail -> false
  end
;

: unify-fail? ( UnifyResult -- Bool )
  match
    UnifyOk -> drop false
    UnifyFail -> true
  end
;

: unify-ok-subst ( UnifyResult -- Subst )
  0 variant.field-at ;

# ============================================
# Parse Result
# ============================================

union ParseResult {
  ParseOkTerm { term: Term, remaining: TokenList }
  ParseOkClause { clause: Clause, remaining: TokenList }
  ParseOkQuery { goals: GoalList, remaining: TokenList }
  ParseErr { message: String, span: SourceSpan }
}

# Forward declare TokenList (defined in tokenizer.seq)
union TokenList {
  TNil
  TCons { token: Token, rest: TokenList }
}

union Token {
  Tok { text: String, span: SourceSpan }
}

: make-parse-ok-term ( Term TokenList -- ParseResult )
  Make-ParseOkTerm ;

: make-parse-ok-clause ( Clause TokenList -- ParseResult )
  Make-ParseOkClause ;

: make-parse-ok-query ( GoalList TokenList -- ParseResult )
  Make-ParseOkQuery ;

: make-parse-err ( String SourceSpan -- ParseResult )
  Make-ParseErr ;

: parse-ok-term? ( ParseResult -- Bool )
  match
    ParseOkTerm -> drop drop true
    ParseOkClause -> drop drop false
    ParseOkQuery -> drop drop false
    ParseErr -> drop drop false
  end
;

: parse-ok-clause? ( ParseResult -- Bool )
  match
    ParseOkTerm -> drop drop false
    ParseOkClause -> drop drop true
    ParseOkQuery -> drop drop false
    ParseErr -> drop drop false
  end
;

: parse-ok-query? ( ParseResult -- Bool )
  match
    ParseOkTerm -> drop drop false
    ParseOkClause -> drop drop false
    ParseOkQuery -> drop drop true
    ParseErr -> drop drop false
  end
;

: parse-err? ( ParseResult -- Bool )
  match
    ParseOkTerm -> drop drop false
    ParseOkClause -> drop drop false
    ParseOkQuery -> drop drop false
    ParseErr -> drop drop true
  end
;

: parse-term-value ( ParseResult -- Term )
  0 variant.field-at ;

: parse-term-remaining ( ParseResult -- TokenList )
  1 variant.field-at ;

: parse-clause-value ( ParseResult -- Clause )
  0 variant.field-at ;

: parse-clause-remaining ( ParseResult -- TokenList )
  1 variant.field-at ;

: parse-query-goals ( ParseResult -- GoalList )
  0 variant.field-at ;

: parse-query-remaining ( ParseResult -- TokenList )
  1 variant.field-at ;

: parse-err-message ( ParseResult -- String )
  0 variant.field-at ;

: parse-err-span ( ParseResult -- SourceSpan )
  1 variant.field-at ;

# ============================================
# Arithmetic Evaluation Result
# ============================================

union ArithResult {
  ArithInt { value: Int }
  ArithFloat { value: Float }
  ArithErr { message: String }
}

: make-arith-int ( Int -- ArithResult )
  Make-ArithInt ;

: make-arith-float ( Float -- ArithResult )
  Make-ArithFloat ;

: make-arith-err ( String -- ArithResult )
  Make-ArithErr ;

: arith-int? ( ArithResult -- Bool )
  match
    ArithInt -> drop true
    ArithFloat -> drop false
    ArithErr -> drop false
  end
;

: arith-float? ( ArithResult -- Bool )
  match
    ArithInt -> drop false
    ArithFloat -> drop true
    ArithErr -> drop false
  end
;

: arith-err? ( ArithResult -- Bool )
  match
    ArithInt -> drop false
    ArithFloat -> drop false
    ArithErr -> drop true
  end
;

: arith-int-value ( ArithResult -- Int )
  0 variant.field-at ;

: arith-float-value ( ArithResult -- Float )
  0 variant.field-at ;

: arith-err-message ( ArithResult -- String )
  0 variant.field-at ;

# ============================================
# Term Pretty Printing
# ============================================

: term-to-string ( Term -- String )
  dup tatom? if
    tatom-name
  else
    dup tvar? if
      dup tvar-name
      dup string.empty? if
        drop "_G" swap tvar-id int->string string.concat
      else
        nip
      then
    else
      dup tint? if
        tint-value int->string
      else
        dup tfloat? if
          tfloat-value float->string
        else
          dup tcompound? if
            dup tcompound-functor
            "(" string.concat
            swap tcompound-args termlist-to-string string.concat
            ")" string.concat
          else
            dup tlist? if
              "[" swap list-contents-to-string string.concat
              "]" string.concat
            else
              drop "<?>"
            then
          then
        then
      then
    then
  then
;

: termlist-to-string ( TermList -- String )
  dup tlnil? if
    drop ""
  else
    dup tlcar term-to-string
    swap tlcdr
    dup tlnil? if
      drop
    else
      ", " swap termlist-to-string string.concat string.concat
    then
  then
;

# Convert list contents to string (handles [H|T] notation)
: list-contents-to-string ( Term -- String )
  dup tempty-list? if
    drop ""
  else
    dup tlist? if
      dup tlist-head term-to-string
      swap tlist-tail
      dup tempty-list? if
        drop
      else
        dup tlist? if
          ", " swap list-contents-to-string string.concat string.concat
        else
          "|" swap term-to-string string.concat string.concat
        then
      then
    else
      # Non-list tail (improper list)
      term-to-string
    then
  then
;

: clause-to-string ( Clause -- String )
  dup clause-head term-to-string
  swap clause-body
  dup gnull? if
    drop "." string.concat
  else
    swap " :- " string.concat
    swap goals-to-string string.concat
    "." string.concat
  then
;

: goals-to-string ( GoalList -- String )
  dup gnull? if
    drop ""
  else
    dup gcar term-to-string
    swap gcdr
    dup gnull? if
      drop
    else
      ", " swap goals-to-string string.concat string.concat
    then
  then
;
