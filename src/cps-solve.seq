# CPS-Based Prolog Solver - Phase 1: Simple Recursive Version
#
# This is a simplified recursive solver that returns SolveResult directly.
# It solves for the first solution only (like solve-first) but with
# cleaner implementation as a stepping stone to full CPS.
#
# Phase 2 will add answer deduplication.
# Phase 3 will add proper backtracking via closures.

include "term"
include "runtime/unify"
include "builtins"
include "runtime/solve"  # For matching-clauses, SolveResult types

# ============================================
# Variable Map (for proper renaming)
# ============================================
# A simple association list mapping variable names to fresh IDs.
# This ensures the same name in head and body gets the same ID.

union VarMap {
  VMEmpty
  VMCons { name: String, id: Int, rest: VarMap }
}

: vm-empty ( -- VarMap ) Make-VMEmpty ;

: vm-cons ( String Int VarMap -- VarMap )
  Make-VMCons ;

: vm-empty? ( VarMap -- Bool )
  match
    VMEmpty -> true
    VMCons -> drop drop drop false
  end
;

: vm-name ( VarMap -- String )
  0 variant.field-at ;

: vm-id ( VarMap -- Int )
  1 variant.field-at ;

: vm-rest ( VarMap -- VarMap )
  2 variant.field-at ;

# Lookup name in map, return id or -1 if not found
: vm-lookup ( String VarMap -- Int )
  dup vm-empty? if
    drop drop -1
  else
    dup vm-name
    2 pick string.equal? if
      nip vm-id
    else
      vm-rest vm-lookup
    then
  then
;

# ============================================
# Proper Clause Renaming (with shared variables)
# ============================================

# Rename a variable, using the map to ensure consistency
# ( Term VarMap Int -- Term VarMap Int )
: rename-var-with-map ( Term VarMap Int -- Term VarMap Int )
  # Stack: term map counter
  2 pick tvar-name        # term map counter name
  2 pick vm-lookup        # term map counter id-or-neg1
  dup 0 i.< if
    # Not in map - add new entry
    drop                  # term map counter

    # Create new-var with name and counter as id
    2 pick tvar-name      # term map counter name
    over                  # term map counter name counter
    tvar                  # term map counter new-var

    # Create new map: vm-cons ( String Int VarMap -- VarMap )
    3 pick tvar-name      # term map counter new-var name
    2 pick                # term map counter new-var name counter
    4 pick                # term map counter new-var name counter map
    vm-cons               # term map counter new-var map'

    # Increment counter
    rot                   # term map new-var map' counter
    1 i.+                 # term map new-var map' counter'

    # Clean up: need new-var map' counter'
    # Stack: term map new-var map' counter' (5 items)
    4 roll drop           # map new-var map' counter'
    3 roll drop           # new-var map' counter'
  else
    # Found in map - use existing id
    # Stack: term map counter id
    3 pick tvar-name      # term map counter id name
    swap                  # term map counter name id
    tvar                  # term map counter new-var

    # Clean up: need new-var map counter
    # Stack: term map counter new-var (4 items)
    3 roll drop           # map counter new-var
    rot rot               # new-var map counter
  then
;

# Rename term with map
: rename-term-with-map ( Term VarMap Int -- Term VarMap Int )
  2 pick tvar? if
    rename-var-with-map
  else
    2 pick tcompound? if
      # Stack: term map counter
      2 pick tcompound-functor   # term map counter functor
      3 pick tcompound-args      # term map counter functor args
      3 pick                     # term map counter functor args map
      3 pick                     # term map counter functor args map counter
      rename-termlist-with-map   # term map counter functor args' map' counter'
      # Stack: term map counter functor args' map' counter'
      # positions: counter'(0), map'(1), args'(2), functor(3), counter(4), map(5), term(6)

      # Get functor and args' to top for tcompound (functor deeper, args' on top)
      3 roll                     # term map counter args' map' counter' functor
      3 roll                     # term map counter map' counter' functor args'
      tcompound                  # term map counter map' counter' term'

      # Clean up: need term' map' counter'
      # Stack: term map counter map' counter' term' (6 items)
      5 roll drop                # map counter map' counter' term'
      4 roll drop                # counter map' counter' term'
      3 roll drop                # map' counter' term'
      rot rot                    # term' map' counter'
    else
      # Atom or other non-var/non-compound term: return unchanged
      # Stack is already: term map counter
    then
  then
;

# Rename term list with map
: rename-termlist-with-map ( TermList VarMap Int -- TermList VarMap Int )
  2 pick tlnil? if
    # Empty - return as is
  else
    # Stack: list map counter
    2 pick tlcar                 # list map counter first
    2 pick                       # list map counter first map
    2 pick                       # list map counter first map counter
    rename-term-with-map         # list map counter first' map' counter'
    # Stack: list map counter first' map' counter' (6 items)
    5 roll tlcdr                 # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-termlist-with-map     # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: rest' is now at pos 3
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build list' = first' :: rest'
    tlcons                       # map counter map' counter' map'' counter'' list'
    # Drop junk (4 items)
    3 roll drop
    3 roll drop
    3 roll drop
    3 roll drop
    rot rot                      # list' map'' counter''
  then
;

# Rename goals with map
: rename-goals-with-map ( GoalList VarMap Int -- GoalList VarMap Int )
  2 pick gnull? if
    # Empty - return as is
  else
    # Stack: goals map counter
    2 pick gcar                  # goals map counter first
    2 pick                       # goals map counter first map
    2 pick                       # goals map counter first map counter
    rename-term-with-map         # goals map counter first' map' counter'
    # Stack: goals map counter first' map' counter' (6 items)
    # pos: 0=counter', 1=map', 2=first', 3=counter, 4=map, 5=goals
    5 roll gcdr                  # map counter first' map' counter' rest
    2 pick                       # map counter first' map' counter' rest map'
    2 pick                       # map counter first' map' counter' rest map' counter'
    rename-goals-with-map        # map counter first' map' counter' rest' map'' counter''
    # Stack: map counter first' map' counter' rest' map'' counter'' (8 items)
    # pos: 0=counter'', 1=map'', 2=rest', 3=counter', 4=map', 5=first', 6=counter, 7=map
    # Need: goals' map'' counter'' where goals' = first' :: rest'

    # Get first' (pos 5) to top
    5 roll                       # map counter map' counter' rest' map'' counter'' first'
    # After 5 roll: pos: 0=first', 1=counter'', 2=map'', 3=rest', 4=counter', 5=map', 6=counter, 7=map
    # Get rest' (now at pos 3) to top
    3 roll                       # map counter map' counter' map'' counter'' first' rest'
    # Build goals' = first' :: rest'
    gcons                        # map counter map' counter' map'' counter'' goals'
    # Stack now 7 items: 0=goals', 1=counter'', 2=map'', 3=counter', 4=map', 5=counter, 6=map

    # Drop counter', map', counter, map (positions 3, 4, 5, 6)
    3 roll drop                  # map counter map' map'' counter'' goals'
    3 roll drop                  # map counter map'' counter'' goals'
    3 roll drop                  # map map'' counter'' goals'
    3 roll drop                  # map'' counter'' goals'
    rot rot                      # goals' map'' counter''
  then
;

# Rename clause with proper variable sharing
: rename-clause-proper ( Clause Int -- Clause Int )
  # Stack: clause counter
  vm-empty                       # clause counter map
  rot                            # counter map clause
  dup clause-head                # counter map clause head
  2 pick                         # counter map clause head map
  4 pick                         # counter map clause head map counter
  rename-term-with-map           # counter map clause head' map' counter'
  # Stack: counter map clause head' map' counter' (6 items)
  3 roll clause-body             # counter map head' map' counter' body
  2 pick                         # counter map head' map' counter' body map'
  2 pick                         # counter map head' map' counter' body map' counter'
  rename-goals-with-map          # counter map head' map' counter' body' map'' counter''
  # Stack: counter map head' map' counter' body' map'' counter'' (8 items)
  # pos: 0=counter'', 1=map'', 2=body', 3=counter', 4=map', 5=head', 6=map, 7=counter
  # Need: clause' counter'' (where clause' = make-clause head' body')

  # Get head' (pos 5) to top
  5 roll                         # counter map map' counter' body' map'' counter'' head'
  # After 5 roll: pos: 0=head', 1=counter'', 2=map'', 3=body', 4=counter', 5=map', 6=map, 7=counter
  # Get body' (now pos 3) to top
  3 roll                         # counter map map' counter' map'' counter'' head' body'
  # make-clause ( Term GoalList -- Clause )
  make-clause                    # counter map map' counter' map'' counter'' clause'
  # Stack: 7 items, clause' on top

  # Get counter'' (pos 1) next to clause'
  swap                           # counter map map' counter' map'' clause' counter''
  # Stack: 7 items. pos: 6=counter, 5=map, 4=map', 3=counter', 2=map'', 1=clause', 0=counter''
  # Need to drop 5 items: map, map', counter', map'', counter
  5 roll drop                    # counter map' counter' map'' clause' counter'' (6 items)
  4 roll drop                    # counter counter' map'' clause' counter'' (5 items)
  3 roll drop                    # counter map'' clause' counter'' (4 items)
  2 roll drop                    # counter clause' counter'' (3 items)
  2 roll drop                    # clause' counter'' (2 items)
;

# ============================================
# Simple Recursive Solver
# ============================================

# solve-simple: Solve goals, return first solution
# ( GoalList Subst ClauseDB Int -- SolveResult Int )
: solve-simple ( GoalList Subst ClauseDB Int -- SolveResult Int )
  # Stack: goals subst db counter
  3 pick gnull? if
    # No goals - SUCCESS!
    # Return success with current substitution
    # Stack: goals subst db counter
    # Need to produce: SolveResult counter
    # make-solve-success needs: Subst ChoiceStack Int -- SolveResult
    nip                  # goals subst counter (drop db)
    rot drop             # subst counter (drop goals)
    swap                 # counter subst
    cpnil                # counter subst cpnil
    2 pick               # counter subst cpnil counter
    make-solve-success   # counter SolveResult
    swap                 # SolveResult counter
  else
    # Have goals - solve first one
    # Stack: goals subst db counter
    3 pick gcar        # Stack: goals subst db counter first-goal

    # Check if it's a built-in
    dup builtin? if
      solve-simple-builtin
    else
      solve-simple-user-goal
    then
  then
;

# Solve a built-in predicate
# Stack: goals subst db counter goal
: solve-simple-builtin ( GoalList Subst ClauseDB Int Term -- SolveResult Int )
  # Execute the builtin with current subst
  3 pick swap        # goals subst db counter subst goal
  swap exec-builtin  # goals subst db counter UnifyResult
  # Stack: goals subst db counter UnifyResult

  dup unify-ok? if
    # Builtin succeeded
    unify-ok-subst     # new-subst
    # Stack: goals subst db counter new-subst

    # Continue with remaining goals
    4 pick gcdr        # rest-goals
    # Stack: goals subst db counter new-subst rest-goals

    swap               # rest-goals new-subst
    3 pick             # rest-goals new-subst db
    3 pick             # rest-goals new-subst db counter
    # Stack: goals subst db counter rest-goals new-subst db counter

    solve-simple       # Stack: goals subst db counter SolveResult counter'

    # Clean up original args
    rot drop           # goals subst db SolveResult counter'
    rot drop           # goals subst SolveResult counter'
    rot drop           # goals SolveResult counter'
    rot drop           # SolveResult counter'
  else
    # Builtin failed
    drop               # drop UnifyResult
    # Stack: goals subst db counter
    drop drop drop drop
    "Builtin failed" no-span make-solve-error
    0                  # SolveResult counter
  then
;

# Solve a user-defined goal
# Stack: goals subst db counter goal
: solve-simple-user-goal ( GoalList Subst ClauseDB Int Term -- SolveResult Int )
  # Find matching clauses
  dup 3 pick matching-clauses
  # Stack: goals subst db counter goal matches

  # Try the matching clauses
  try-simple-clauses
;

# Try matching clauses, return first success
# Stack: goals subst db counter goal matches
: try-simple-clauses ( GoalList Subst ClauseDB Int Term ClauseDB -- SolveResult Int )
  dup db-empty? if
    # No more clauses - FAIL
    drop drop          # drop matches, goal
    drop drop drop drop  # drop counter, db, subst, goals
    make-solve-failure
    0                  # SolveResult counter
  else
    # Try first clause
    dup db-first       # get first clause
    3 pick             # get counter
    rename-clause-proper
    # Stack: goals subst db counter goal matches clause' counter'
    swap               # Stack: goals subst db counter goal matches counter' clause'

    # Unify goal with clause head
    # Stack: goals subst db counter goal matches counter' clause'
    # Positions (top=0): 0=clause', 1=counter', 2=matches, 3=goal, 4=counter, 5=db, 6=subst, 7=goals
    dup clause-head    # clause' head
    # Stack: goals subst db counter goal matches counter' clause' head
    # Positions: 0=head, 1=clause', 2=counter', 3=matches, 4=goal, 5=counter, 6=db, 7=subst, 8=goals
    4 pick             # goal
    # Stack: goals subst db counter goal matches counter' clause' head goal
    # Positions: 0=goal, 1=head, 2=clause', 3=counter', 4=matches, 5=goal, 6=counter, 7=db, 8=subst, 9=goals
    swap               # head goal
    8 pick             # subst (fixed: was 7, now 8)
    unify
    # Stack: goals subst db counter goal matches counter' clause' UnifyResult

    dup unify-ok? if
      # Unification succeeded!
      unify-ok-subst   # new-subst
      # Stack: goals subst db counter goal matches counter' clause' new-subst

      # Build new goal list: clause-body ++ rest-of-goals
      over clause-body   # clause-body
      9 pick gcdr        # rest of original goals
      gappend            # new-goals
      # Stack: goals subst db counter goal matches counter' clause' new-subst new-goals

      # Call solve-simple recursively
      swap               # new-goals new-subst
      7 pick             # new-goals new-subst db
      4 pick             # new-goals new-subst db counter'
      # Stack: goals subst db counter goal matches counter' clause' new-goals new-subst db counter'

      solve-simple       # Stack: goals subst db counter goal matches counter' clause' SolveResult counter''

      # Check if we succeeded
      over solve-success? if
        # SUCCESS! Clean up and return
        # Stack: goals subst db counter goal matches counter' clause' SolveResult counter''
        rot drop         # drop clause'
        rot drop         # drop counter'
        rot drop         # drop matches
        rot drop         # drop goal
        rot drop         # drop counter
        rot drop         # drop db
        rot drop         # drop subst
        rot drop         # drop goals
        # Stack: SolveResult counter''
      else
        # This clause didn't work, try next
        # Stack: goals subst db counter goal matches counter' clause' SolveResult counter''
        drop drop        # drop counter'', SolveResult
        drop drop        # drop clause', counter'
        db-rest          # remaining matches
        # Stack: goals subst db counter goal rest-matches
        try-simple-clauses
      then
    else
      # Unification failed - try next clause
      # Stack: goals subst db counter goal matches counter' clause' UnifyResult
      drop             # drop UnifyResult: goals subst db counter goal matches counter' clause'
      drop             # drop clause': goals subst db counter goal matches counter'
      drop             # drop counter': goals subst db counter goal matches
      db-rest          # remaining matches
      # Stack: goals subst db counter goal rest-matches
      try-simple-clauses
    then
  then
;

# ============================================
# Entry Points
# ============================================

# Run a query and print the first solution
: run-simple-query ( GoalList ClauseDB -- )
  swap               # db goals
  subst-empty        # db goals subst
  rot                # goals subst db
  0                  # goals subst db counter

  solve-simple       # SolveResult counter
  drop               # drop counter

  # Print result
  dup solve-success? if
    solve-success-subst print-simple-subst
    "." io.write-line
  else
    dup solve-failure? if
      drop "false." io.write-line
    else
      "Error: " swap solve-error-message string.concat io.write-line
    then
  then
;

: print-simple-subst ( Subst -- )
  dup subst-empty? if
    drop "true" io.write
  else
    dup subst-binding
    dup binding-var-id int->string
    " = " string.concat
    swap binding-value term-to-string string.concat
    io.write-line
    subst-parent print-simple-subst
  then
;

# ============================================
# Test Harness
# ============================================

: test-simple ( -- )
  "=== Simple Recursive Solver Test ===" io.write-line

  # Build database with recursive ancestor:
  # parent(tom, mary).
  # parent(mary, ann).
  # ancestor(X, Y) :- parent(X, Y).
  # ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).

  "tom" tatom "mary" tatom tlnil tlcons tlcons
  "parent" swap tcompound
  make-fact

  "mary" tatom "ann" tatom tlnil tlcons tlcons
  "parent" swap tcompound
  make-fact

  # Stack: fact1 fact2

  # NOTE: Add recursive FIRST so that after matching-clauses reverses,
  # base case will be tried first (avoiding infinite recursion)

  # ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).  (recursive - add first)
  "X" 200 tvar "Y" 201 tvar tlnil tlcons tlcons
  "ancestor" swap tcompound
  "X" 200 tvar "Z" 202 tvar tlnil tlcons tlcons
  "parent" swap tcompound
  "Z" 202 tvar "Y" 201 tvar tlnil tlcons tlcons
  "ancestor" swap tcompound
  gnull gcons gcons
  make-clause
  # Stack: fact1 fact2 ancestor-recursive

  # ancestor(X, Y) :- parent(X, Y).  (base case - add second, so tried first)
  "X" 100 tvar "Y" 101 tvar tlnil tlcons tlcons
  "ancestor" swap tcompound
  "X" 100 tvar "Y" 101 tvar tlnil tlcons tlcons
  "parent" swap tcompound
  gnull gcons
  make-clause
  # Stack: fact1 fact2 ancestor-recursive ancestor-base

  db-empty db-append db-append db-append db-append
  # Stack: db

  "Test 1: parent(tom, mary)" io.write-line
  dup
  "tom" tatom "mary" tatom tlnil tlcons tlcons
  "parent" swap tcompound
  gnull gcons
  swap run-simple-query

  "Test 2: ancestor(tom, mary) - direct" io.write-line
  dup
  "tom" tatom "mary" tatom tlnil tlcons tlcons
  "ancestor" swap tcompound
  gnull gcons
  swap run-simple-query

  "Test 3: ancestor(tom, ann) - via mary" io.write-line
  "tom" tatom "ann" tatom tlnil tlcons tlcons
  "ancestor" swap tcompound
  gnull gcons
  swap run-simple-query

  "=== Test Complete ===" io.write-line
;

: main ( -- )
  test-simple
;
